pub use __cargo_equip::prelude::*;

use std::borrow::Cow;

use cpio::*;
use ds::{DynamicSortedSequence, MapMonoid};

#[derive(Clone)]
struct T;
impl MapMonoid for T {
    type M = (Cow<'static, str>, usize);
    type Act = ();

    fn e() -> Self::M {
        ("".into(), usize::MAX)
    }
    fn op(_: &Self::M, _: &Self::M) -> Self::M {
        ("".into(), usize::MAX)
    }

    fn id() -> Self::Act {}
    fn composite(_: &Self::Act, _: &Self::Act) -> Self::Act {}

    fn map(_: &Self::M, _: &Self::Act) -> Self::M {
        ("".into(), usize::MAX)
    }
}

fn main() {
    scan! {n: usize, q: usize, s: [String; n]}

    let mut seq = s
        .into_iter()
        .enumerate()
        .map(|(i, s)| (s.into(), i))
        .collect::<DynamicSortedSequence<T>>();
    for _ in 0..q {
        scan! {x: usize, t: String}

        let (_, index) = seq.remove(x - 1);
        seq.insert((t.into(), index));
    }

    let mut seq = seq
        .into_iter()
        .map(|s| (s.0.as_ref().to_owned(), s.1))
        .collect::<Vec<_>>();
    seq.sort_by_key(|s| s.1);
    putln!(seq.into_iter().map(|v| v.0), @sep = " ");
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `cpio 0.1.0 (path+███████████████████████████████████)` published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::cpio`
///  - `ds 0.1.0 (path+█████████████████████████████████)`     published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::ds`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod cpio {pub use crate::__cargo_equip::macros::cpio::*;#[cfg(target_family="unix")]mod ext{use std::os::raw::{c_int,c_long,c_void};extern "C"{pub fn mmap(addr:*mut c_void,len:usize,prot:c_int,flags:c_int,fd:c_int,offset:c_long,)->*mut c_void;}pub const PROT_READ:i32=1;pub const MAP_PRIVATE:i32=2;}mod input{use std::{fs::File,io::Read,str::from_utf8};use crate::__cargo_equip::crates::cpio::parse_number::{parse16c,parse4c,parse8c};#[inline(always)]const fn parse_small_integer(bytes:&[u8],d:usize)->u64{const S:u64=b'0' as u64*11;const T:u64=b'0' as u64*111;debug_assert!(0<d&&d<4);match d{1=>(bytes[0]&15)as u64,2=>bytes[0]as u64*10+bytes[1]as u64-S,3=>bytes[0]as u64*100+bytes[1]as u64*10+bytes[2]as u64-T,_=>unreachable!(),}}pub trait FromBytes{fn from_bytes(bytes:&[u8])->Self;}impl FromBytes for u64{fn from_bytes(bytes:&[u8])->Self{debug_assert!(!bytes.is_empty()&&bytes.len()<=20);const TEN:[u64;4]=[1,10,100,1000];unsafe{match bytes.len(){1=>parse_small_integer(bytes,1),2=>parse_small_integer(bytes,2),3=>parse_small_integer(bytes,3),4=>parse4c(bytes.try_into().unwrap()),8=>parse8c(bytes.try_into().unwrap()),12=>{parse4c(bytes[..4].try_into().unwrap())*100_000_000+parse8c(bytes[4..].try_into().unwrap())}16=>parse16c(bytes),20=>{parse16c(bytes[..16].try_into().unwrap())*10_000+parse4c(bytes[16..].try_into().unwrap())}len=>{let offset=len&!0b11;Self::from_bytes(&bytes[..offset])*TEN[len&0b11]+parse_small_integer(&bytes[offset..],len&0b11)}}}}}macro_rules!impl_unsigned_integer_from_bytes{($($t:ty),*)=>{$(impl FromBytes for$t{fn from_bytes(bytes:&[u8])->Self{<u64 as FromBytes>::from_bytes(bytes)as$t}})*};}impl_unsigned_integer_from_bytes!(u8,u16,u32,usize);impl FromBytes for u128{fn from_bytes(bytes:&[u8])->Self{if bytes.len()>19{const P:u128=10u128.pow(19);let offset=bytes.len()-19;u64::from_bytes(&bytes[..offset])as u128*P+u64::from_bytes(&bytes[offset..])as u128}else{u64::from_bytes(bytes)as u128}}}macro_rules!impl_signed_integer_from_bytes{($($s:ty,$u:ty),*)=>{$(impl FromBytes for$s{fn from_bytes(bytes:&[u8])->Self{debug_assert!(!bytes.is_empty());let sgn=bytes[0]==b'-';let mut res=<$u as FromBytes>::from_bytes(&bytes[sgn as usize..]);debug_assert!(res<=<$s>::MAX as$u+sgn as$u);if sgn{res=res.wrapping_neg();}res as$s}})*};}impl_signed_integer_from_bytes!(i8,u8,i16,u16,i32,u32,i64,u64,isize,usize,i128,u128);impl FromBytes for char{fn from_bytes(bytes:&[u8])->Self{debug_assert!(!bytes.is_empty());let mut it=from_utf8(bytes).expect("Malformed UTF-8 byte sequence").chars();let res=it.next().unwrap();assert!(it.next().is_none(),"Failed to parse `char`: multiple characters");res}}impl FromBytes for String{fn from_bytes(bytes:&[u8])->Self{from_utf8(bytes).expect("Malformed UTF-8 byte sequence").to_owned()}}pub struct Source{buf:Box<[u8]>,_file:Option<File>,head:usize,}impl Source{fn get_buffer_use_std(stdin:&mut impl Read)->Box<[u8]>{let mut buf=Vec::with_capacity(1<<18);stdin.read_to_end(&mut buf).unwrap();buf.resize(buf.len()+32,b' ');buf.into_boxed_slice()}#[cfg(target_family="unix")]pub fn new()->Self{use std::{os::fd::FromRawFd,ptr::{null_mut,slice_from_raw_parts_mut},};use crate::__cargo_equip::crates::cpio::ext::{mmap,MAP_PRIVATE,PROT_READ};let mut stdin=unsafe{File::from_raw_fd(0)};let meta=stdin.metadata().unwrap();let buf=if meta.is_file(){let len=meta.len()as usize;let mapping=unsafe{mmap(null_mut()as _,len,PROT_READ,MAP_PRIVATE,0,0)};let res=slice_from_raw_parts_mut(mapping as*mut u8,len);unsafe{Box::from_raw(res)}}else{Self::get_buffer_use_std(&mut stdin)};Self{buf,_file:Some(stdin),head:0,}}#[cfg(not(target_family="unix"))]pub fn new()->Self{let buf=Self::get_buffer_use_std(&mut std::io::stdin().lock());Self{buf,_file:None,head:0,}}pub fn next_start(&mut self)->Option<usize>{while self.buf.get(self.head)?<=&b' '{self.head+=1;}Some(self.head)}pub fn next_token(&mut self)->&[u8]{let head=self.next_start().expect("There are no more tokens");while self.buf.get(self.head).filter(|&&b|b>b' ').is_some(){self.head+=1;}&self.buf[head..self.head]}}static mut INPUT:*mut Source=0 as*mut Source;static mut STDIN_SOURCE:fn()->&'static mut Source=init;#[cold]fn init()->&'static mut Source{unsafe{INPUT=Box::leak(Box::new(Source::new()));STDIN_SOURCE=||INPUT.as_mut().unwrap_unchecked();STDIN_SOURCE()}}pub fn get_stdin_source()->&'static mut Source{unsafe{STDIN_SOURCE()}}}mod output{use std::{cell::RefCell,io::Write,iter,ptr::{addr_of_mut,write_volatile},};const LUT:[u8;40000]={let mut cnt=0;let mut lut=[0;40000];while cnt<10000{let th=cnt/1000;let hu=cnt/100%10;let te=cnt/10%10;let on=cnt%10;lut[cnt*4]=th as u8+b'0';lut[cnt*4+1]=hu as u8+b'0';lut[cnt*4+2]=te as u8+b'0';lut[cnt*4+3]=on as u8+b'0';cnt+=1;}lut};pub trait Display{fn fmt(&self,buf:&mut Buffer,sep:&str);}#[inline(always)]fn write_small_integer(int:u16,buf:&mut Buffer){debug_assert!(int<10000);let base=int as usize*4;buf.write_unchecked(&LUT[base+3-int.ilog10()as usize..base+4]);}macro_rules!impl_stringify_unsigned_integer{($t:ty$(as$convert:ty)?,$st:ty,$block:literal)=>{impl Display for$t{fn fmt(&self,f:&mut Buffer,_:&str){f.reserve($block*4);let mut now=*self$(as$convert)?;if now==0{f.write_unchecked("0".as_bytes());return;}if now<10000{write_small_integer(now as u16,f);return;}let mut t=[0;$block];let mut cnt=$block;while now>=10000{cnt-=1;(now,t[cnt])=(now/10000,(now%10000)as u16);}write_small_integer(now as u16,f);for&t in&t[cnt..]{let t=t as usize;f.write_unchecked(&LUT[t*4..t*4+4]);}}}impl Display for$st{fn fmt(&self,buf:&mut Buffer,sep:&str){if*self<0{buf.write("-".as_bytes());self.unsigned_abs().fmt(buf,sep);}else{(*self as$t).fmt(buf,sep);}}}};}impl_stringify_unsigned_integer!(u8 as u32,i8,0);impl_stringify_unsigned_integer!(u16 as u32,i16,2);impl_stringify_unsigned_integer!(u32,i32,3);impl_stringify_unsigned_integer!(u64,i64,5);impl_stringify_unsigned_integer!(usize,isize,5);impl_stringify_unsigned_integer!(u128,i128,10);impl Display for char{fn fmt(&self,buf:&mut Buffer,_:&str){let mut b=[0;4];buf.write(self.encode_utf8(&mut b).as_bytes());}}impl Display for str{fn fmt(&self,buf:&mut Buffer,_:&str){buf.write(self.as_bytes());}}impl<T:Display>Display for[T]{fn fmt(&self,buf:&mut Buffer,sep:&str){if let Some(item)=self.first(){item.fmt(buf,sep);for item in self.iter().skip(1){buf.write(sep.as_bytes());item.fmt(buf,sep);}}}}macro_rules!impl_base_ust{($ty:ty,$b:ty,$($t:tt)*)=>{impl<$($t)*>Display for$ty{fn fmt(&self,buf:&mut Buffer,sep:&str){<$b as Display>::fmt(self,buf,sep)}}};}impl_base_ust!(&str,str,);impl_base_ust!(String,str,);impl_base_ust!(&[T],[T],T:Display);impl_base_ust!([T;N],[T],T:Display,const N:usize);impl_base_ust!(Vec<T>,[T],T:Display);macro_rules!impl_fmt_iterator{($t:ty,$($g:tt)*)=>{impl<$($g)*>Display for$t{fn fmt(&self,buf:&mut Buffer,sep:&str){let mut iter=self.clone();if let Some(item)=iter.next(){item.fmt(buf,sep);for item in iter{buf.write(sep.as_bytes());item.fmt(buf,sep);}}}}};}impl_fmt_iterator!(std::slice::Iter<'_,T>,T:Display);impl_fmt_iterator!(iter::Chain<A,B>,T:Display,A:Clone+Iterator<Item=T>,B:Clone+Iterator<Item=T>);impl_fmt_iterator!(iter::Cloned<I>,'a,T:Display+Clone+'a,I:Clone+Iterator<Item=&'a T>);impl_fmt_iterator!(iter::Copied<I>,'a,T:Display+Clone+Copy+'a,I:Clone+Iterator<Item=&'a T>);impl_fmt_iterator!(iter::Cycle<I>,T:Display,I:Clone+Iterator<Item=T>);impl_fmt_iterator!(iter::Filter<I,P>,T:Display,I:Clone+Iterator<Item=T>,P:Clone+FnMut(&I::Item)->bool);impl_fmt_iterator!(iter::FilterMap<I,F>,T:Display,I:Clone+Iterator,F:Clone+FnMut(I::Item)->Option<T>);impl_fmt_iterator!(iter::Map<I,F>,T:Display,I:Clone+Iterator,F:Clone+FnMut(I::Item)->T);impl_fmt_iterator!(iter::Skip<I>,T:Display,I:Clone+Iterator<Item=T>);impl_fmt_iterator!(iter::StepBy<I>,T:Display,I:Clone+Iterator<Item=T>);impl_fmt_iterator!(iter::Take<I>,T:Display,I:Clone+Iterator<Item=T>);pub struct Buffer{head:usize,buf:[u8;Self::LEN],}impl Buffer{const LEN:usize=1<<20;const fn new()->Self{Self{head:0,buf:[0;Self::LEN]}}fn reserve(&mut self,len:usize){assert!(len<=Self::LEN);if self.head+len>Self::LEN{self.flush();}}fn write_unchecked(&mut self,buf:&[u8]){self.buf[self.head..self.head+buf.len()].copy_from_slice(buf);self.head+=buf.len();}fn write(&mut self,buf:&[u8]){if self.head+buf.len()<=Self::LEN{self.write_unchecked(buf);return;}for c in buf.chunks(Self::LEN){self.flush();self.buf[..c.len()].copy_from_slice(c);self.head=c.len();}}fn flush(&mut self){if self.head>0{std::io::stdout().write_all(&self.buf[..self.head]).ok();self.head=0;}}}struct DumFlush(u32);impl Drop for DumFlush{fn drop(&mut self){get_output().flush();}}thread_local!{static DUMMY:RefCell<DumFlush> =const{RefCell::new(DumFlush(0))};}static mut BUFFER:Buffer=Buffer::new();static mut GET_BUFFER:fn()->&'static mut Buffer=init;#[cold]fn init()->&'static mut Buffer{DUMMY.with(|d|unsafe{write_volatile(addr_of_mut!(d.borrow_mut().0),32)});unsafe{GET_BUFFER=get_output}get_output()}fn get_output()->&'static mut Buffer{unsafe{addr_of_mut!(BUFFER).as_mut().unwrap()}}pub fn get_buffer()->&'static mut Buffer{unsafe{GET_BUFFER()}}}mod parse_number{pub(in crate::__cargo_equip::crates::cpio)unsafe fn parse4c(buf:[u8;4])->u64{let mut chunk=u32::from_le_bytes(buf);chunk-=0x30303030;chunk=(chunk*10+(chunk>>8))&0xff00ff;((chunk*100+(chunk>>16))&0xffff)as u64}pub(in crate::__cargo_equip::crates::cpio)unsafe fn parse8c(buf:[u8;8])->u64{let mut chunk=u64::from_le_bytes(buf);chunk-=0x3030303030303030;chunk=(chunk*10+(chunk>>8))&0xff00ff00ff00ff;chunk=(chunk*100+(chunk>>16))&0xffff0000ffff;(chunk*10000+(chunk>>32))&0xffffffff}#[cfg(not(target_arch="x86_64"))]pub(in crate::__cargo_equip::crates::cpio)unsafe fn parse16c(buf:&[u8])->u64{let buf:[u8;16]=buf.try_into().unwrap();let mut chunk=u128::from_le_bytes(buf);chunk-=0x30303030303030303030303030303030;chunk=(chunk*10+(chunk>>8))&0xff00ff00ff00ff00ff00ff00ff00ff;chunk=(chunk*100+(chunk>>16))&0xffff0000ffff0000ffff0000ffff;chunk=(chunk*10000+(chunk>>32))&0xffffffff00000000ffffffff;((chunk*100000000+(chunk>>64))&0xffffffffffffffff)as u64}#[cfg(target_arch="x86_64")]mod x86_64{use std::arch::x86_64::{__m128i,_mm_cvtsi128_si64,_mm_lddqu_si128,_mm_madd_epi16,_mm_maddubs_epi16,_mm_packus_epi32,_mm_sub_epi8,};use std::mem::transmute;const ZEROS:__m128i=unsafe{transmute([b'0';16])};const TEN:__m128i=unsafe{transmute([[10u8,1u8];8])};const HUN:__m128i=unsafe{transmute([[100u8,0,1,0];4])};const THO:__m128i=unsafe{transmute([16u8,39,1,0,16,39,1,0,0,0,0,0,0,0,0,0])};#[target_feature(enable="sse2",enable="sse3",enable="ssse3",enable="sse4.1")]pub unsafe fn parse16c(buf:&[u8])->u64{let mut chunk=_mm_lddqu_si128(buf.as_ptr()as _);chunk=_mm_madd_epi16(_mm_maddubs_epi16(_mm_sub_epi8(chunk,ZEROS),TEN),HUN);chunk=_mm_madd_epi16(_mm_packus_epi32(chunk,chunk),THO);let res=_mm_cvtsi128_si64(chunk)as u64;((res&0xffffffff)*100_000_000)+(res>>32)}}#[cfg(target_arch="x86_64")]pub(crate)use x86_64::parse16c;}pub use input::{get_stdin_source,FromBytes,Source};pub use output::{get_buffer,Display};#[macro_export]macro_rules!__cargo_equip_macro_def_cpio_scan{(@src$src:ident,@mut[$($mut:tt)?],@id[$v:tt],@ty[$($ty:tt)*],@rest$(,$($rest:tt)*)?)=>{$crate::__cargo_equip::crates::cpio::read_value!(@src$src,@mut[$($mut)?],@id[$v],@ty[$($ty)*]);$crate::__cargo_equip::crates::cpio::scan!(@src$src,$($($rest)*)?);};(@src$src:ident,@mut[$($mut:tt)?],@id[$v:tt],@ty[$($ty:tt)*],@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::cpio::scan!(@src$src,@mut[$($mut)?],@id[$v],@ty[$($ty)*$t],@rest$($rest)*);};(@src$src:ident,@mut[$($mut:tt)?],@rest$v:tt:$($t:tt)*)=>{$crate::__cargo_equip::crates::cpio::scan!(@src$src,@mut[$($mut)?],@id[$v],@ty[],@rest$($t)*);};(@src$src:ident,@mut[],@rest mut$($t:tt)*)=>{$crate::__cargo_equip::crates::cpio::scan!(@src$src,@mut[mut],@rest$($t)*);};(@src$src:ident,$($t:tt)+)=>{$crate::__cargo_equip::crates::cpio::scan!(@src$src,@mut[],@rest$($t)+);};(@src$src:ident,)=>{};($($t:tt)+)=>{let mut __cpio_source_lock_object=$crate::__cargo_equip::crates::cpio::get_stdin_source();$crate::__cargo_equip::crates::cpio::scan!(@src __cpio_source_lock_object,$($t)+);};()=>{::std::compile_error!("Failed to parse macro");}}macro_rules!scan{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_cpio_scan!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_cpio_read_value{(@src$src:ident,@mut[$($mut:tt)?],@id[$v:tt],@ty[$($t:tt)*])=>{let$($mut)?$v=$crate::__cargo_equip::crates::cpio::read_value!(@src$src,@ty[$($t)*]);};(@src$src:ident,@ty[[$($t:tt)*]])=>{$crate::__cargo_equip::crates::cpio::read_value!(@arr@src$src,@ty[],@rest$($t)*)};(@arr@src$src:ident,@ty[$($ty:tt)*],@rest;const$($len:tt)*)=>{{const LEN:usize=($($len)*);let mut arr=[$crate::__cargo_equip::crates::cpio::read_value!(@src$src,@ty[$($ty)*]);LEN];for i in 1..LEN{arr[i]=$crate::__cargo_equip::crates::cpio::read_value!(@src$src,@ty[$($ty)*]);}arr}};(@arr@src$src:ident,@ty[$($ty:tt)*],@rest;$($len:tt)*)=>{{let len=($($len)*);(0..len).map(|_|$crate::__cargo_equip::crates::cpio::read_value!(@src$src,@ty[$($ty)*])).collect::<Vec<_>>()}};(@arr@src$src:ident,@ty[$($ty:tt)*],@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::cpio::read_value!(@arr@src$src,@ty[$($ty)*$t],@rest$($rest)*)};(@src$src:ident,@ty[($($t:tt)*)])=>{$crate::__cargo_equip::crates::cpio::read_value!(@tup@src$src,@ty[],@cur[],@rest$($t)*)};(@tup@src$src:ident,@ty[$([$($ty:tt)*])*],@cur[],@rest)=>{($($crate::__cargo_equip::crates::cpio::read_value!(@src$src,@ty[$($ty)*]),)*)};(@tup@src$src:ident,@ty[$([$($ty:tt)*])*],@cur[$($cur:tt)*],@rest)=>{$crate::__cargo_equip::crates::cpio::read_value!(@tup@src$src,@ty[$([$($ty)*])*[$($cur)*]],@cur[],@rest)};(@tup@src$src:ident,@ty[$([$($ty:tt)*])*],@cur[$($cur:tt)*],@rest,$($rest:tt)*)=>{$crate::__cargo_equip::crates::cpio::read_value!(@tup@src$src,@ty[$([$($ty)*])*[$($cur)*]],@cur[],@rest$($rest)*)};(@tup@src$src:ident,@ty[$([$($ty:tt)*])*],@cur[$($cur:tt)*],@rest$t:tt$($rest:tt)*)=>{$crate::__cargo_equip::crates::cpio::read_value!(@tup@src$src,@ty[$([$($ty)*])*],@cur[$($cur)*$t],@rest$($rest)*)};(@src$src:ident,@ty[$t:ty])=>{{<$t as$crate::__cargo_equip::crates::cpio::FromBytes>::from_bytes($src.next_token())}};(@src$src:ident,@ty[])=>{::std::compile_error!("Failed to parse macro");};}macro_rules!read_value{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_cpio_read_value!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_cpio_put{($arg:expr$(,$args:expr)*,@sep=$sep:expr)=>{$crate::__cargo_equip::crates::cpio::Display::fmt(&$arg,$crate::__cargo_equip::crates::cpio::get_buffer(),$sep);$crate::__cargo_equip::crates::cpio::put!(@tail,$($args),*,@sep=$sep);};(@tail,$($args:expr),*,@sep=$sep:expr)=>{$($crate::__cargo_equip::crates::cpio::Display::fmt(&$sep,$crate::__cargo_equip::crates::cpio::get_buffer(),"");$crate::__cargo_equip::crates::cpio::Display::fmt(&$args,$crate::__cargo_equip::crates::cpio::get_buffer(),$sep);)*};($arg:expr)=>{$crate::__cargo_equip::crates::cpio::Display::fmt(&$arg,$crate::__cargo_equip::crates::cpio::get_buffer(),"\n");};($($args:expr),*)=>{$crate::__cargo_equip::crates::cpio::put!($($args),*,@sep="\n");};()=>{}}macro_rules!put{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_cpio_put!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_cpio_putln{($($args:expr),+,@sep=$sep:expr)=>{$crate::__cargo_equip::crates::cpio::put!($($args),+,@sep=$sep);$crate::__cargo_equip::crates::cpio::putln!();};($($args:expr),+)=>{$crate::__cargo_equip::crates::cpio::put!($($args),+);$crate::__cargo_equip::crates::cpio::putln!();};()=>{$crate::__cargo_equip::crates::cpio::put!("\n");}}macro_rules!putln{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_cpio_putln!{$($tt)*})}}
        pub mod ds {mod btree_multiset{use std::{collections::BTreeMap,fmt::Debug,ops::RangeBounds};pub struct BTreeMultiSet<K>{len:usize,inner:BTreeMap<K,u32>,}impl<'a,K:Ord+Debug+Clone>BTreeMultiSet<K>{#[inline]pub fn new()->Self{Self{len:0,inner:BTreeMap::new()}}#[inline]pub fn insert(&mut self,key:K){*self.inner.entry(key).or_insert(0)+=1;self.len+=1;}#[inline]pub fn remove(&mut self,key:&K){if!self.inner.contains_key(key){return;}self.len-=1;if*self.inner.get(key).unwrap()==1{self.inner.remove(key);}else{*self.inner.get_mut(key).unwrap()-=1;}}#[inline]pub fn remove_all(&mut self,key:&K){self.len-=*self.inner.get(key).unwrap_or(&0)as usize;self.inner.remove(key);}#[inline]pub fn count(&mut self,key:&K)->usize{*self.inner.get(key).unwrap_or(&0)as usize}#[inline]pub fn len(&self)->usize{self.len}#[inline]pub fn clear(&mut self){self.inner.clear();self.len=0;}#[inline]pub fn has_duplicate(&self)->bool{self.len()!=self.inner.len()}#[inline]pub fn contains(&self,key:&K)->bool{self.inner.contains_key(key)}#[inline]pub fn first(&self)->Option<&K>{self.inner.iter().next().map(|(k,_)|k)}#[inline]pub fn get(&self,key:&K)->Option<&K>{self.inner.get_key_value(key).map(|(k,_)|k)}#[inline]pub fn is_empty(&self)->bool{self.inner.is_empty()}#[inline]pub fn last(&self)->Option<&K>{self.inner.iter().next_back().map(|(k,_)|k)}#[inline]pub fn iter(&'a self)->impl DoubleEndedIterator<Item=&'a K>+'a{self.inner.iter().flat_map(|(k,&cnt)|(0..cnt).map(move|_|k))}#[inline]pub fn range<R:RangeBounds<K>>(&'a self,range:R,)->impl DoubleEndedIterator<Item=&'a K>+'a{self.inner.range(range).flat_map(|(k,&cnt)|(0..cnt).map(move|_|k))}}impl<K:Ord+Debug+Clone>Default for BTreeMultiSet<K>{fn default()->Self{Self::new()}}}mod cartesian_tree{#[derive(Debug,Clone)]pub struct CartesianTree{root:usize,par:Vec<u32>,left:Vec<u32>,right:Vec<u32>,}impl CartesianTree{pub fn new<T:Ord>(a:Vec<T>)->Self{let len=a.len();let mut res=Self{root:0,par:vec![u32::MAX;len],left:vec![u32::MAX;len],right:vec![u32::MAX;len],};let mut stack=vec![];for i in 0..len{let mut p=u32::MAX;while let Some(last)=stack.pop(){if a[last]<a[i]{stack.push(last);stack.push(i);res.par[i]=last as u32;res.right[last]=i as u32;break;}p=last as u32;}if stack.is_empty(){stack.push(i);}if p<u32::MAX{res.left[i]=p;res.par[p as usize]=i as u32;}}res.root=stack[0];res}pub const fn root(&self)->usize{self.root}pub fn left(&self,index:usize)->Option<usize>{(self.left[index]<u32::MAX).then_some(self.left[index]as usize)}pub fn right(&self,index:usize)->Option<usize>{(self.right[index]<u32::MAX).then_some(self.right[index]as usize)}pub fn parent(&self,index:usize)->Option<usize>{(self.par[index]<u32::MAX).then_some(self.par[index]as usize)}pub fn parlist(&self)->Vec<Option<usize>>{(0..self.par.len()).map(|i|self.parent(i)).collect()}}}mod dynamic_sequence{use std::cell::{Cell,RefCell,RefMut};use std::fmt::Debug;use std::ops::{Bound,Range,RangeBounds};use std::ptr::copy;use std::rc::Rc;use std::sync::atomic::{AtomicUsize,Ordering};use crate::__cargo_equip::crates::ds::convert_range;use crate::__cargo_equip::crates::ds::splay_tree::{Node,NodeAllocator};use crate::__cargo_equip::crates::ds::{splay_tree::{NodeData,NodeRef},DefaultZST,MapMonoid,};static DATA_INDEX:AtomicUsize=AtomicUsize::new(0);struct DSData<M:MapMonoid>{index:usize,size:usize,val:M::M,sum:M::M,lazy:M::Act,}impl<M>DSData<M>where M:MapMonoid,M::M:Clone,{fn new()->Self{let index=DATA_INDEX.fetch_add(1,Ordering::Relaxed);assert!(index<1<<62);Self{index,size:1,val:M::e(),sum:M::e(),lazy:M::id()}}fn with_value(val:M::M)->Self{let mut res=Self::new();res.val=val;res.sum=res.val.clone();res}const fn is_reversed(&self)->bool{self.index>=1<<63}const fn has_lazy(&self)->bool{self.index>=1<<62}fn set_lazy(&mut self,act:&M::Act){if self.has_lazy(){self.lazy=M::composite(&self.lazy,act);}else{self.index|=1<<62;unsafe{copy(act as _,&mut self.lazy as _,1)}}}}impl<M>NodeData for DSData<M>where M:MapMonoid,M::M:Clone,{fn index(&self)->usize{self.index&!(0b11<<62)}fn propagate(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>){if self.has_lazy(){if let Some(mut left)=left{left.data.val=M::map(&left.data.val,&self.lazy);left.data.sum=M::map(&left.data.sum,&self.lazy);left.data.set_lazy(&self.lazy);if self.is_reversed(){left.toggle();}}if let Some(mut right)=right{right.data.val=M::map(&right.data.val,&self.lazy);right.data.sum=M::map(&right.data.sum,&self.lazy);right.data.set_lazy(&self.lazy);if self.is_reversed(){right.toggle();}}self.lazy=M::id();self.index=self.index();}}fn update(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>){match(left,right){(Some(l),Some(r))=>{self.size=l.data.size+r.data.size+1;self.sum=M::op(&M::op(&l.data.sum,&self.val),&r.data.sum)}(Some(l),_)=>{self.size=l.data.size+1;self.sum=M::op(&l.data.sum,&self.val)}(_,Some(r))=>{self.size=r.data.size+1;self.sum=M::op(&self.val,&r.data.sum)}_=>{self.size=1;self.sum=self.val.clone();}};}fn aggrmove(&mut self,source:NodeRef<Self>){self.size=source.data.size;self.sum=source.data.sum.clone();}fn toggle(&mut self){self.index^=1<<63;M::reverse(&mut self.sum);}}impl<M:MapMonoid>PartialEq for DSData<M>{fn eq(&self,other:&Self)->bool{self.index==other.index}}impl<M>Debug for DSData<M>where M:MapMonoid,M::M:Debug+Clone,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("DSData").field("index",&self.index()).field("size",&self.size).field("val",&self.val).field("sum",&self.sum).field("lazy",&self.lazy).finish()}}impl<M>Default for DSData<M>where M:MapMonoid,M::M:Clone,{fn default()->Self{Self::new()}}pub struct DynamicSequence<M:MapMonoid=DefaultZST>where M::M:Clone,{root:Cell<Option<NodeRef<DSData<M>>>>,alloc:Rc<RefCell<NodeAllocator<DSData<M>>>>,}impl<M>DynamicSequence<M>where M:MapMonoid,M::M:Clone,{pub fn new(size:usize)->Self{(0..size).map(|_|M::e()).collect()}pub fn len(&self)->usize{self.root.get().map_or(0,|r|r.data.size)}pub fn is_empty(&self)->bool{self.len()==0}fn convert_range(&self,range:impl RangeBounds<usize>)->Range<usize>{let res=convert_range(self.len(),range);assert!(res.start<=res.end&&res.end<=self.len()&&res.start<=self.len());res}fn nth_node(&self,n:usize)->Option<NodeRef<DSData<M>>>{let mut node=self.root.get()?;(n<node.data.size).then(||{let mut rem=n+1;loop{node.propagate();if let Some(left)=node.left(){if left.data.size>=rem{node=left;continue;}rem-=left.data.size;}if rem==1{node.splay();debug_assert_eq!(node.left().map_or(0,|l|l.data.size),n);self.root.set(Some(node));break node;}rem-=1;node=node.right().expect("Inconsistent node size");}})}pub fn get(&self,nth:usize)->Option<&M::M>{unsafe{Some(&self.nth_node(nth)?.0.as_ref().data.val)}}fn split_off_inner(&self,at:usize)->DynamicSequence<M>{if at==0{return Self{root:Cell::new(self.root.take()),alloc:Rc::clone(&self.alloc),};}if at==self.len(){return Self{root:Cell::new(None),alloc:Rc::clone(&self.alloc)};}let mut back=self.nth_node(at).unwrap_or_else(||panic!("`self.len()` is {}, but `at` is {at}",self.len()));let front=back.disconnect_left();back.update();self.root.set(front);Self{root:Cell::new(Some(back)),alloc:Rc::clone(&self.alloc)}}pub fn split_off(&mut self,at:usize)->DynamicSequence<M>{self.split_off_inner(at)}fn append_inner(&self,other:Self){let Some(other)=other.root.take()else{return;};let Some(mut root)=self.last_node()else{self.root.set(Some(other));return;};root.connect_right(other);root.update();self.root.set(Some(root));}pub fn append(&mut self,other:Self){self.append_inner(other);}pub fn insert(&mut self,at:usize,element:M::M){assert!(at<=self.len());let new=self.alloc.borrow_mut().alloc(DSData::with_value(element));let mid=Self{root:Cell::new(Some(new)),alloc:Rc::clone(&self.alloc)};let back=self.split_off(at);self.append(mid);self.append(back);}fn first_node(&self)->Option<NodeRef<DSData<M>>>{let mut node=self.root.get()?;node.propagate();while let Some(left)=node.left(){node=left;node.propagate();}node.splay();self.root.set(Some(node));Some(node)}fn last_node(&self)->Option<NodeRef<DSData<M>>>{let mut node=self.root.get()?;node.propagate();while let Some(right)=node.right(){node=right;node.propagate();}node.splay();Some(node)}pub fn push_first(&mut self,element:M::M){self.insert(0,element);}pub fn push_last(&mut self,element:M::M){self.insert(self.len(),element);}pub fn pop_first(&mut self)->Option<M::M>{let mut root=self.first_node()?;self.root.set(root.disconnect_right());let data=std::mem::take(&mut root.data);self.alloc.borrow_mut().dealloc(root);Some(data.val)}pub fn pop_last(&mut self)->Option<M::M>{let mut root=self.last_node()?;self.root.set(root.disconnect_left());let data=std::mem::take(&mut root.data);self.alloc.borrow_mut().dealloc(root);Some(data.val)}pub fn remove(&mut self,at:usize)->M::M{assert!(at<self.len());let mut back=self.split_off(at);let res=back.pop_first().unwrap();self.append(back);res}pub fn reverse(&mut self,range:impl RangeBounds<usize>){if self.is_empty(){return;}let range=self.convert_range(range);if range.len()<=1{return;}let back=self.split_off(range.end);let mid=self.split_off(range.start);let mut root=mid.root.get().unwrap();root.toggle();root.propagate();self.extend(mid);self.extend(back);}pub fn set(&mut self,at:usize,val:M::M){let mut n=self.nth_node(at).unwrap();n.data.val=val;n.update();self.root.set(Some(n));}pub fn update_by(&mut self,at:usize,mut f:impl FnMut(&M::M)->M::M){let mut n=self.nth_node(at).unwrap();n.data.val=f(&n.data.val);n.update();self.root.set(Some(n));}pub fn apply_range(&mut self,range:impl RangeBounds<usize>,act:&M::Act){if self.is_empty(){return;}let range=self.convert_range(range);if range.is_empty(){return;}if range.len()==1{self.update_by(range.start,|m|M::map(m,act));return;}let back=self.split_off(range.end);let mid=self.split_off(range.start);let mut root=mid.root.get().unwrap();root.data.val=M::map(&root.data.val,act);root.data.sum=M::map(&root.data.sum,act);root.data.set_lazy(act);root.propagate();self.extend(mid);self.extend(back);}pub fn fold(&self,range:impl RangeBounds<usize>)->M::M{if self.is_empty(){return M::e();}let range=self.convert_range(range);if range.is_empty(){return M::e();}if range.len()==self.len(){return M::op(&M::e(),&self.root.get().unwrap().data.sum);}let back=self.split_off_inner(range.end);let mid=self.split_off_inner(range.start);let res=M::op(&M::e(),&mid.root.get().unwrap().data.sum);self.append_inner(mid);self.append_inner(back);res}pub fn iter(&self)->Iter<'_,M>{Iter{seq:self,node:self.first_node()}}}impl<M>Debug for DynamicSequence<M>where M:MapMonoid,M::M:Debug+Clone,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("DynamicSequence").field("root",&self.root.get()).finish()}}impl<M>Clone for DynamicSequence<M>where M:MapMonoid,M::M:Clone,M::Act:Clone,{fn clone(&self)->Self{let mut cloned=Self{root:Cell::new(None),alloc:Rc::clone(&self.alloc)};cloned.extend(self.iter().cloned());cloned}}impl<M>Extend<M::M>for DynamicSequence<M>where M:MapMonoid,M::M:Clone,{fn extend<T:IntoIterator<Item=M::M>>(&mut self,iter:T){iter.into_iter().for_each(|e|self.push_last(e));}}impl<M>Default for DynamicSequence<M>where M:MapMonoid,M::M:Clone,{fn default()->Self{Self{root:Cell::new(None),alloc:Rc::new(RefCell::new(NodeAllocator::default())),}}}impl<M>Drop for DynamicSequence<M>where M:MapMonoid,M::M:Clone,{fn drop(&mut self){fn dealloc_recursive<M>(node:Option<NodeRef<DSData<M>>>,alloc:&mut RefMut<NodeAllocator<DSData<M>>>,)->Option<()>where M:MapMonoid,M::M:Clone,{let node=node?;dealloc_recursive(node.disconnect_left(),alloc);dealloc_recursive(node.disconnect_right(),alloc);alloc.dealloc(node);Some(())}if Rc::strong_count(&self.alloc)>1{dealloc_recursive(self.root.take(),&mut self.alloc.borrow_mut());}}}impl<M>FromIterator<M::M>for DynamicSequence<M>where M:MapMonoid,M::M:Clone,{fn from_iter<T:IntoIterator<Item=M::M>>(iter:T)->Self{let buf=iter.into_iter().map(|val|Node::new(DSData::with_value(val))).collect::<Box<[Node<DSData<M>>]>>();let len=buf.len();let mut alloc=NodeAllocator::from_buffer(buf);Self{root:Cell::new((0..len).map(|_|alloc.alloc_uninitialized()).reduce(|s,mut v|{v.connect_left(s);v.update();v}),),alloc:Rc::new(RefCell::new(alloc)),}}}#[derive(Clone)]pub struct Iter<'a,M:MapMonoid>where M::M:Clone,{seq:&'a DynamicSequence<M>,node:Option<NodeRef<DSData<M>>>,}impl<'a,M>Iterator for Iter<'a,M>where M:MapMonoid,M::M:Clone,{type Item=&'a M::M;fn next(&mut self)->Option<Self::Item>{let mut node=self.node.take()?;if!node.is_root(){node.splay();}let res=unsafe{&node.0.as_ref().data.val};if let Some(mut next)=node.right(){node.propagate();next.propagate();while let Some(n)=next.left(){next=n;next.propagate();}next.splay();self.node=Some(next);self.seq.root.set(Some(next));}Some(res)}}pub struct IntoIter<M:MapMonoid>where M::M:Clone,{seq:DynamicSequence<M>,}impl<M>Clone for IntoIter<M>where M:MapMonoid,M::M:Clone,M::Act:Clone,{fn clone(&self)->Self{Self{seq:self.seq.clone()}}}impl<M>Iterator for IntoIter<M>where M:MapMonoid,M::M:Clone,{type Item=M::M;fn next(&mut self)->Option<Self::Item>{self.seq.pop_first()}}impl<M>DoubleEndedIterator for IntoIter<M>where M:MapMonoid,M::M:Clone,{fn next_back(&mut self)->Option<Self::Item>{self.seq.pop_last()}}impl<M>IntoIterator for DynamicSequence<M>where M:MapMonoid,M::M:Clone,{type Item=M::M;type IntoIter=IntoIter<M>;fn into_iter(self)->Self::IntoIter{Self::IntoIter{seq:self}}}pub struct DynamicSortedSequence<M:MapMonoid>where M::M:Clone,{seq:DynamicSequence<M>,}impl<M:MapMonoid>DynamicSortedSequence<M>where M::M:Ord+Clone,{pub fn new()->Self{Self{seq:DynamicSequence::new(0)}}pub fn len(&self)->usize{self.seq.len()}pub fn is_empty(&self)->bool{self.seq.is_empty()}pub fn get(&self,nth:usize)->Option<&M::M>{self.seq.get(nth)}pub fn indexes_of(&self,element:&M::M)->Option<Range<usize>>{let start=self.first_index_of(element)?;let end=self.upper_bound_node(element).map(|n|n.left().map(|l|l.data.size).unwrap_or(self.len()))?;Some(start..end)}pub fn first_index_of(&self,element:&M::M)->Option<usize>{Some(self.lower_bound_node(element).filter(|n|&n.data.val==element)?.left().map(|l|l.data.size).unwrap_or(0),)}pub fn last_index_of(&self,element:&M::M)->Option<usize>{self.indexes_of(element).map(|range|range.end-1)}pub fn contains(&self,element:&M::M)->bool{self.first_index_of(element).is_some()}pub fn split_off(&mut self,at:usize)->DynamicSortedSequence<M>{let seq=self.seq.split_off(at);Self{seq}}fn lower_bound_node(&self,element:&M::M)->Option<NodeRef<DSData<M>>>{let mut node=self.seq.root.get()?;let mut ok=None::<NodeRef<DSData<M>>>;loop{node.propagate();if&node.data.val<element{if let Some(right)=node.right(){node=right;}else{let res=ok?;res.splay();self.seq.root.set(Some(node));break ok;}}else{ok=Some(node);if let Some(left)=node.left(){node=left;}else{node.splay();self.seq.root.set(Some(node));break Some(node);}}}}fn upper_bound_node(&self,element:&M::M)->Option<NodeRef<DSData<M>>>{let mut node=self.seq.root.get()?;let mut ok=None::<NodeRef<DSData<M>>>;loop{node.propagate();if&node.data.val<=element{if let Some(right)=node.right(){node=right;}else{let res=ok?;res.splay();self.seq.root.set(Some(node));break Some(res);}}else{ok=Some(node);if let Some(left)=node.left(){node=left;}else{node.splay();self.seq.root.set(Some(node));break Some(node);}}}}pub fn split_off_by(&mut self,element:&M::M)->DynamicSortedSequence<M>{let Some(mut root)=self.lower_bound_node(element)else{return Self::new();};let left=root.disconnect_left();root.update();self.seq.root.set(left);Self{seq:DynamicSequence{root:Cell::new(Some(root)),alloc:Rc::clone(&self.seq.alloc),},}}pub fn insert(&mut self,element:M::M){let mut new=self.seq.alloc.borrow_mut().alloc(DSData::with_value(element));if let Some(mut node)=self.lower_bound_node(&new.data.val){if let Some(left)=node.disconnect_left(){node.update();new.connect_left(left);}new.connect_right(node);new.update();}else if let Some(root)=self.seq.root.take(){new.connect_left(root);new.update();}self.seq.root.set(Some(new));}pub fn pop_first(&mut self)->Option<M::M>{self.seq.pop_first()}pub fn pop_last(&mut self)->Option<M::M>{self.seq.pop_last()}pub fn first(&self)->Option<&M::M>{self.seq.first_node().map(|node|unsafe{&node.0.as_ref().data.val})}pub fn last(&self)->Option<&M::M>{self.seq.last_node().map(|node|unsafe{&node.0.as_ref().data.val})}pub fn remove(&mut self,at:usize)->M::M{self.seq.remove(at)}pub fn remove_once(&mut self,element:&M::M)->Option<M::M>{let mut back=self.split_off_by(&element);if back.first()!=Some(element){self.seq.extend(back.seq);return None;}let res=back.pop_first();self.seq.append(back.seq);res}pub fn remove_all<'a>(&'a mut self,element:&'a M::M)->impl Iterator<Item=M::M>+'a{std::iter::from_fn(move||self.remove_once(element))}pub fn fold(&self,range:impl RangeBounds<usize>)->M::M{self.seq.fold(range)}pub fn range(&self,range:impl RangeBounds<M::M>)->RangeIter<'_,M>{RangeIter{node:match range.start_bound(){Bound::Unbounded=>self.seq.first_node(),Bound::Excluded(m)=>self.upper_bound_node(m),Bound::Included(m)=>self.lower_bound_node(m),},end:match range.end_bound(){Bound::Unbounded=>None,Bound::Excluded(m)=>self.lower_bound_node(m),Bound::Included(m)=>self.upper_bound_node(m),},seq:&self.seq,}}pub fn iter(&self)->Iter<'_,M>{self.seq.iter()}}impl<M>Clone for DynamicSortedSequence<M>where M:MapMonoid,M::M:Clone,M::Act:Clone,{fn clone(&self)->Self{Self{seq:self.seq.clone()}}}impl<M>Extend<M::M>for DynamicSortedSequence<M>where M:MapMonoid,M::M:Ord+Clone,{fn extend<T:IntoIterator<Item=M::M>>(&mut self,iter:T){iter.into_iter().for_each(|elem|self.insert(elem));}}impl<M>Debug for DynamicSortedSequence<M>where M:MapMonoid,M::M:Debug+Clone,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("DynamicSortedSequence").field("root",&self.seq.root.get()).finish()}}impl<M>Default for DynamicSortedSequence<M>where M:MapMonoid,M::M:Ord+Clone,{fn default()->Self{Self::new()}}impl<M>FromIterator<M::M>for DynamicSortedSequence<M>where M:MapMonoid,M::M:Ord+Clone,{fn from_iter<T:IntoIterator<Item=M::M>>(iter:T)->Self{let mut v=iter.into_iter().collect::<Vec<_>>();v.sort_unstable();Self{seq:v.into_iter().collect()}}}impl<M>IntoIterator for DynamicSortedSequence<M>where M:MapMonoid,M::M:Clone,{type Item=M::M;type IntoIter=IntoIter<M>;fn into_iter(self)->Self::IntoIter{self.seq.into_iter()}}pub struct RangeIter<'a,M:MapMonoid>where M::M:Clone,{node:Option<NodeRef<DSData<M>>>,end:Option<NodeRef<DSData<M>>>,seq:&'a DynamicSequence<M>,}impl<'a,M>Iterator for RangeIter<'a,M>where M:MapMonoid,M::M:Clone,{type Item=&'a M::M;fn next(&mut self)->Option<Self::Item>{(self.node.map(|n|n.data.index())!=self.end.map(|n|n.data.index())).then(||{let mut node=self.node.take()?;if!node.is_root(){node.splay();}let res=unsafe{&node.0.as_ref().data.val};if let Some(mut next)=node.right(){node.propagate();next.propagate();while let Some(n)=next.left(){next=n;next.propagate();}node.splay();self.node=Some(next);self.seq.root.set(Some(next));}Some(res)}).flatten()}}impl<'a,M>DoubleEndedIterator for RangeIter<'a,M>where M:MapMonoid,M::M:Clone,{fn next_back(&mut self)->Option<Self::Item>{(self.node.map(|n|n.data.index())!=self.end.map(|n|n.data.index())).then(||{if let Some(mut end)=self.end{if!end.is_root(){end.splay();}let res=unsafe{&end.0.as_ref().data.val};if let Some(mut prev)=end.left(){end.propagate();prev.propagate();while let Some(n)=prev.right(){prev=n;prev.propagate();}prev.splay();self.end=Some(prev);self.seq.root.set(Some(prev));}Some(res)}else{let end=self.seq.last_node()?;let res=unsafe{&end.0.as_ref().data.val};self.end=Some(end);Some(res)}}).flatten()}}}mod euler_tour_tree{use crate::__cargo_equip::crates::ds::splay_tree::{Node,NodeAllocator,NodeData,NodeRef};use crate::__cargo_equip::crates::ds::DefaultZST;use super::MapMonoid;use std::cell::RefCell;use std::collections::hash_map::RandomState;use std::collections::HashMap;use std::fmt::Debug;use std::rc::Rc;pub(in crate::__cargo_equip::crates::ds)struct EttData<M:MapMonoid=DefaultZST>{index:usize,val:M::M,sum:M::M,lazy:M::Act,size:u32,flag:u8,}impl<M:MapMonoid>EttData<M>{fn new(src:usize,dest:usize,own_layer:bool)->Self{debug_assert!(src.max(dest)<=0xFFFFFFFF);let index=(src<<32)|dest;let own_layer=(src!=dest&&own_layer)as u8;Self{index,val:M::e(),sum:M::e(),lazy:M::id(),size:(src==dest)as u32,flag:(own_layer<<2)|(own_layer<<3),}}fn source(&self)->usize{self.index()>>32}fn destination(&self)->usize{self.index()&0xFFFFFFFF}fn is_self_loop(&self)->bool{self.source()==self.destination()}}impl<M:MapMonoid>NodeData for EttData<M>{fn index(&self)->usize{self.index}fn propagate(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>){if let Some(mut left)=left{left.data.lazy=M::composite(&left.data.lazy,&self.lazy);left.data.val=M::map(&left.data.val,&self.lazy);left.data.sum=M::map(&left.data.sum,&self.lazy);}if let Some(mut right)=right{right.data.lazy=M::composite(&right.data.lazy,&self.lazy);right.data.val=M::map(&right.data.val,&self.lazy);right.data.sum=M::map(&right.data.sum,&self.lazy);}self.lazy=M::id();}fn update(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>){self.sum=match(left,right){(Some(l),Some(r))=>{self.size=l.data.size+r.data.size+self.is_self_loop()as u32;let b=(l.data.flag|r.data.flag|(self.flag<<1))&0b1010;self.flag=b|(self.flag&0b0101);M::op(&M::op(&l.data.sum,&self.val),&r.data.sum)}(Some(l),_)=>{self.size=l.data.size+self.is_self_loop()as u32;let b=(l.data.flag|(self.flag<<1))&0b1010;self.flag=b|(self.flag&0b0101);M::op(&l.data.sum,&self.val)}(_,Some(r))=>{self.size=r.data.size+self.is_self_loop()as u32;let b=(r.data.flag|(self.flag<<1))&0b1010;self.flag=b|(self.flag&0b0101);M::op(&self.val,&r.data.sum)}_=>{self.size=self.is_self_loop()as u32;let b=(self.flag<<1)&0b1010;self.flag=b|(self.flag&0b0101);M::op(&self.val,&M::e())}};}fn aggrmove(&mut self,source:NodeRef<Self>){self.size=source.data.size;self.sum=M::op(&M::e(),&source.data.sum);self.flag|=source.data.flag&0b1010;}}impl<M:MapMonoid>Default for EttData<M>{fn default()->Self{Self{index:0,val:M::e(),sum:M::e(),lazy:M::id(),size:0,flag:0,}}}impl<M:MapMonoid>PartialEq for EttData<M>{fn eq(&self,other:&Self)->bool{self.index==other.index}}impl<M>Debug for EttData<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("EttData").field("source",&self.source()).field("destination",&self.destination()).field("size",&self.size).field("val",&self.val).field("sum",&self.sum).field("lazy",&self.lazy).finish()}}impl<M:MapMonoid>NodeRef<EttData<M>>{fn set_aux_edge(mut self){self.data.flag|=0b11;}fn remove_aux_edge(mut self){self.data.flag&=!0b11;self.update_flag();}fn has_aux_edges(self)->bool{self.data.flag&1!=0}fn has_aux_edges_subtree(self)->bool{self.data.flag&0b10!=0}fn unset_as_own_layers_edge(mut self){self.data.flag&=!0b1100;self.update_flag();}fn is_own_layers_edge(self)->bool{self.data.flag&0b100!=0}fn has_own_laysers_edge_on_subtree(self)->bool{self.data.flag&0b1000!=0}fn update_flag(mut self){self.data.flag=((self.left().map_or(0,|l|l.data.flag)|self.right().map_or(0,|r|r.data.flag)|(self.data.flag<<1))&0b1010)|(self.data.flag&0b0101);}fn splay_with_propagate(self){self.propagate_all();self.splay();}}#[derive(Debug,Clone,Copy,PartialEq,Eq)]pub enum EttLinkError{EdgeAlreadyExists,SelfLoop,MakeCycle,}type EdgesMap<M,S> =HashMap<(usize,usize),(NodeRef<EttData<M>>,NodeRef<EttData<M>>),S>;pub struct EulerTourTree<M:MapMonoid,S=RandomState>{vertex:Box<[Node<EttData<M>>]>,edges:EdgesMap<M,S>,alloc:Rc<RefCell<NodeAllocator<EttData<M>>>>,}impl<M:MapMonoid>EulerTourTree<M>{pub fn new(n:usize)->Self{Self::from_edges(n,[]).unwrap()}pub(in crate::__cargo_equip::crates::ds)fn new_in(n:usize,alloc:Rc<RefCell<NodeAllocator<EttData<M>>>>)->Self{Self::from_edges_in(n,[],alloc).unwrap()}pub fn from_edges(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,)->Result<Self,EttLinkError>{Self::from_edges_with_values(n,edges,[])}pub(in crate::__cargo_equip::crates::ds)fn from_edges_in(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,alloc:Rc<RefCell<NodeAllocator<EttData<M>>>>,)->Result<Self,EttLinkError>{Self::from_edges_with_values_in(n,edges,[],alloc)}pub fn from_edges_with_values(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,values:impl IntoIterator<Item=(usize,M::M)>,)->Result<Self,EttLinkError>{Self::from_edges_with_values_in(n,edges,values,Rc::new(RefCell::new(NodeAllocator::with_capacity((n-1)*2))),)}pub(in crate::__cargo_equip::crates::ds)fn from_edges_with_values_in(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,values:impl IntoIterator<Item=(usize,M::M)>,alloc:Rc<RefCell<NodeAllocator<EttData<M>>>>,)->Result<Self,EttLinkError>{let mut vertex=(0..n).map(|i|Node::new(EttData::new(i,i,false))).collect::<Box<[_]>>();for(i,v)in values{vertex[i].data.val=v;vertex[i].update();}let mut res=Self{vertex,edges:HashMap::default(),alloc};for(u,v)in edges{res.link(u,v)?;}Ok(res)}fn nth_vertex(&self,n:usize)->NodeRef<EttData<M>>{assert!(n<self.vertex.len());unsafe{NodeRef::from_raw_unchecked(self.vertex.as_ptr().add(n)as _)}}fn most_left(&self,u:usize)->NodeRef<EttData<M>>{let mut res=self.nth_vertex(u);res.splay_with_propagate();while let Some(left)=res.left(){res=left;res.propagate();}res.splay();res}fn most_left_from(&self,mut r:NodeRef<EttData<M>>)->NodeRef<EttData<M>>{r.propagate();while let Some(nr)=r.left(){r=nr;r.propagate();}r.splay();r}fn most_right_from(&self,mut r:NodeRef<EttData<M>>)->NodeRef<EttData<M>>{r.propagate();while let Some(nr)=r.right(){r=nr;r.propagate();}r.splay();r}pub fn are_connected(&self,u:usize,v:usize)->bool{if u==v||self.edges.contains_key(&(u.min(v),u.max(v))){return true;}self.nth_vertex(u).splay_with_propagate();self.nth_vertex(v).splay_with_propagate();!self.nth_vertex(u).is_root()}pub fn reroot(&mut self,new_root:usize){self.nth_vertex(new_root).splay_with_propagate();self.reroot_inner(new_root);}fn reroot_inner(&mut self,new_root:usize)->Option<NodeRef<EttData<M>>>{self.vertex[new_root].left().is_some().then(||{self.nth_vertex(new_root).splay_with_propagate();let p=self.nth_vertex(new_root).disconnect_left().unwrap();self.nth_vertex(new_root).update();let mut r=self.most_right_from(self.nth_vertex(new_root));r.connect_right(p);r.update();r})}pub fn link(&mut self,u:usize,v:usize)->Result<(),EttLinkError>{self.link_as_specified_layer(u,v,false)}pub(in crate::__cargo_equip::crates::ds)fn link_as_specified_layer(&mut self,u:usize,v:usize,own_layer:bool,)->Result<(),EttLinkError>{if u==v{return Err(EttLinkError::SelfLoop);}if self.has_edge(u,v){return Err(EttLinkError::EdgeAlreadyExists);}if self.are_connected(u,v){return Err(EttLinkError::MakeCycle);}let(u,v)=(u.min(v),u.max(v));let mut uv=self.alloc.borrow_mut().alloc(EttData::new(u,v,own_layer));uv.connect_left(self.reroot_inner(u).unwrap_or(self.nth_vertex(u)));uv.connect_right(self.reroot_inner(v).unwrap_or(self.nth_vertex(v)));uv.update();let vu=self.alloc.borrow_mut().alloc(EttData::new(v,u,false));let mr=self.most_right_from(uv);mr.connect_right(vu);vu.splay_with_propagate();self.edges.insert((u,v),(uv,vu));Ok(())}pub fn cut(&mut self,u:usize,v:usize){if u==v||!self.has_edge(u,v){return;}let Some((l,r))=self.edges.remove(&(u.min(v),u.max(v)))else{return;};l.splay_with_propagate();match(l.disconnect_left(),l.disconnect_right()){(Some(lc),Some(rc))=>{r.splay_with_propagate();if!lc.is_root()||lc==r{r.disconnect_right();if let Some(mut l)=r.disconnect_left(){l=self.most_right_from(l);l.connect_right(rc);l.update();}}else{r.disconnect_left();if let Some(mut rr)=r.disconnect_right(){rr=self.most_left_from(rr);rr.connect_left(lc);rr.update();}}}(Some(_),_)|(_,Some(_))=>{r.splay_with_propagate();r.disconnect_left();r.disconnect_right();}(None,None)=>unreachable!("The pair of a edge is not found"),}self.alloc.borrow_mut().dealloc(l);self.alloc.borrow_mut().dealloc(r);}pub fn tree_size(&self,u:usize)->usize{self.nth_vertex(u).splay_with_propagate();self.nth_vertex(u).data.size as usize}pub(in crate::__cargo_equip::crates::ds)fn set_aux_edge(&mut self,u:usize){if!self.nth_vertex(u).has_aux_edges(){self.nth_vertex(u).splay_with_propagate();self.nth_vertex(u).set_aux_edge();}}pub(in crate::__cargo_equip::crates::ds)fn remove_aux_edge(&mut self,u:usize){self.nth_vertex(u).splay_with_propagate();self.nth_vertex(u).remove_aux_edge();}pub(in crate::__cargo_equip::crates::ds)fn find_vertex_has_aux_edge(&self,u:usize)->Option<usize>{let mut now=self.nth_vertex(u);if!now.has_aux_edges()&&!now.has_aux_edges_subtree(){now.propagate_all();now.splay();}while!now.has_aux_edges()&&now.has_aux_edges_subtree(){if now.left().map_or(false,|l|l.has_aux_edges()||l.has_aux_edges_subtree()){now=now.left().unwrap();}else{now=now.right().unwrap();}}now.has_aux_edges().then(||{now.splay_with_propagate();assert!(now.data.is_self_loop());now.data.source()})}pub(in crate::__cargo_equip::crates::ds)fn find_and_unset_own_layers_edge(&self,u:usize)->Option<(usize,usize)>{let mut now=self.nth_vertex(u);if!now.is_own_layers_edge()&&!now.has_own_laysers_edge_on_subtree(){now.splay_with_propagate();}while!now.is_own_layers_edge()&&now.has_own_laysers_edge_on_subtree(){if now.left().map_or(false,|l|{l.is_own_layers_edge()||l.has_own_laysers_edge_on_subtree()}){now=now.left().unwrap();}else{now=now.right().unwrap();}}now.is_own_layers_edge().then(||{now.splay_with_propagate();now.unset_as_own_layers_edge();assert!(!now.data.is_self_loop());(now.data.source(),now.data.destination())})}pub fn euler_tour_with_vertex(&self,u:usize)->impl Iterator<Item=(usize,usize)>+'_{let mut m=Some(self.most_left(u));std::iter::from_fn(move||{let n=m.take()?;n.splay_with_propagate();if let Some(next)=n.right(){m=Some(self.most_left_from(next));}Some((n.data.source(),n.data.destination()))})}pub fn euler_tour(&self,u:usize)->impl Iterator<Item=(usize,usize)>+'_{self.euler_tour_with_vertex(u).filter(|(u,v)|u!=v)}pub fn edges(&self,u:usize)->impl Iterator<Item=(usize,usize)>+'_{self.euler_tour(u).filter(|e|e.0<e.1)}pub fn vertexes(&self,u:usize)->impl Iterator<Item=usize>+'_{let mut m=Some(self.most_left(u));std::iter::from_fn(move||loop{let n=m.take()?;n.splay_with_propagate();if let Some(next)=n.right(){m=Some(self.most_left_from(next));}if n.data.is_self_loop(){break Some(n.data.source());}})}pub fn has_edge(&self,u:usize,v:usize)->bool{u!=v&&self.edges.contains_key(&(u.min(v),u.max(v)))}pub fn fold(&self,u:usize)->M::M{self.nth_vertex(u).splay_with_propagate();M::op(&M::e(),&self.vertex[u].data.sum)}pub fn set(&mut self,index:usize,value:M::M){self.nth_vertex(index).splay_with_propagate();self.vertex[index].data.val=value;self.vertex[index].update();}pub fn update_by(&mut self,index:usize,f:impl Fn(&M::M)->M::M){self.nth_vertex(index).splay_with_propagate();self.vertex[index].data.val=f(&self.vertex[index].data.val);self.vertex[index].update();}pub fn apply(&mut self,u:usize,act:&M::Act){self.nth_vertex(u).splay_with_propagate();self.vertex[u].data.val=M::map(&self.vertex[u].data.val,act);self.vertex[u].data.lazy=M::composite(&self.vertex[u].data.lazy,act);self.vertex[u].propagate();self.vertex[u].update();}pub fn apply_subtree(&mut self,u:usize,parent:usize,act:&M::Act){if!self.has_edge(u,parent){panic!("There is no link between `{u}` and `{parent}`.");}self.cut(u,parent);self.apply(u,act);self.link(u,parent).unwrap();}pub fn fold_subtree(&self,u:usize,parent:usize)->Option<M::M>{let&(mut l,mut r)=self.edges.get(&(u.min(parent),u.max(parent)))?;if u<parent{(l,r)=(r,l);}l.splay_with_propagate();let(lc,rc)=(l.disconnect_left(),l.disconnect_right());r.splay_with_propagate();Some(match(lc,rc){(Some(lc),Some(rc))=>{if!lc.is_root()||lc==r{l.connect_left(r);l.connect_right(rc);M::op(&rc.data.sum,&r.left().unwrap().data.sum)}else{l.connect_left(lc);l.connect_right(r);M::op(&M::e(),&r.left().unwrap().data.sum)}}(Some(_),_)=>{l.connect_left(r);M::op(&M::e(),&r.left().unwrap().data.sum)}(_,Some(_))=>{l.connect_right(r);M::op(&M::e(),&r.left().unwrap().data.sum)}_=>unreachable!(),})}}impl<M>Debug for EulerTourTree<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("EulerTourTree").field("vertexes",&self.vertex).field("edges",&self.edges).finish()}}}mod fixed_ring_queue{#![allow(clippy::uninit_assumed_init)]use std::mem::MaybeUninit;pub struct FixedRingQueue<T,const SIZE:usize={1<<20}>{buf:[MaybeUninit<T>;SIZE],head:usize,tail:usize,empty:bool,}impl<T,const SIZE:usize>FixedRingQueue<T,SIZE>{const MASK:usize={assert!(1<<SIZE.trailing_zeros()==SIZE);SIZE-1};pub const fn new()->Self{Self{buf:unsafe{MaybeUninit::uninit().assume_init()},head:0,tail:0,empty:true,}}#[inline]pub fn is_empty(&self)->bool{self.empty}#[inline]pub fn is_full(&self)->bool{self.len()==SIZE}#[inline]pub fn len(&self)->usize{self.tail-self.head}#[inline]pub fn capacity(&self)->usize{SIZE}#[inline]pub fn clear(&mut self){self.head=0;self.tail=0;self.empty=true;}pub fn push(&mut self,val:T){debug_assert!(!self.is_full());unsafe{self.buf.as_mut_ptr().add(self.tail&Self::MASK).as_mut().unwrap_unchecked().write(val)};self.tail+=1;self.empty=false;}#[inline]pub unsafe fn pop_unchecked(&mut self)->T{let res=unsafe{std::ptr::replace(self.buf.as_mut_ptr().add(self.head&Self::MASK),MaybeUninit::uninit(),)};self.head+=1;self.empty=self.head==self.tail;res.assume_init()}#[inline]pub fn pop(&mut self)->Option<T>{(!self.is_empty()).then(||unsafe{self.pop_unchecked()})}}impl<T,const SIZE:usize>FromIterator<T>for FixedRingQueue<T,SIZE>{#[inline]fn from_iter<I:IntoIterator<Item=T>>(iter:I)->Self{let mut que=FixedRingQueue::new();iter.into_iter().for_each(|v|que.push(v));que}}impl<T,const SIZE:usize>Extend<T>for FixedRingQueue<T,SIZE>{#[inline]fn extend<I:IntoIterator<Item=T>>(&mut self,iter:I){iter.into_iter().for_each(|v|self.push(v));}}}mod interval_heap{#[derive(Debug,Clone)]pub struct IntervalHeap<T>{heap:Vec<T>,}impl<T>IntervalHeap<T>{pub const fn new()->Self{Self{heap:vec![]}}pub fn len(&self)->usize{self.heap.len()}pub fn is_empty(&self)->bool{self.heap.is_empty()}pub fn shrink_to_fit(&mut self){self.heap.shrink_to_fit();}pub fn with_capacity(capacity:usize)->Self{Self{heap:Vec::with_capacity(capacity)}}pub fn clear(&mut self){self.heap.clear();}}impl<T:Ord>IntervalHeap<T>{fn parent(&self,node:usize)->Option<usize>{(node>1).then_some((node>>1).wrapping_sub(1)&!1)}fn up_heap(&mut self,mut node:usize,root:usize)->usize{if(node|1)<self.len()&&self.heap[node&!1]>self.heap[node|1]{self.heap.swap(node&!1,node|1);node^=1;}let mut par=self.parent(node);while par.is_some()&&root<node&&self.heap[node]<self.heap[par.unwrap()]{self.heap.swap(par.unwrap(),node);node=par.unwrap();par=self.parent(node);}let mut par=self.parent(node);while par.is_some()&&root<node&&self.heap[par.unwrap()|1]<self.heap[node]{self.heap.swap(par.unwrap()|1,node);node=par.unwrap()|1;par=self.parent(node);}node}fn left_child(&self,node:usize)->Option<usize>{let res=node*2+2-(node&1);(res<self.len()).then_some(res)}fn right_child(&self,node:usize)->Option<usize>{let res=node*2+4-(node&1);(res<self.len()).then_some(res)}fn down_heap(&mut self,mut node:usize)->usize{if node&1!=0{while let Some(mut l)=self.left_child(node){if let Some(r)=self.right_child(node){l=if self.heap[l]>self.heap[r]{l}else{r};}if self.heap[node]<self.heap[l]{self.heap.swap(node,l);node=l;}else{break;}}}else{while let Some(mut l)=self.left_child(node){if let Some(r)=self.right_child(node){l=if self.heap[l]<self.heap[r]{l}else{r};}if self.heap[node]>self.heap[l]{self.heap.swap(node,l);node=l;}else{break;}}}node}pub fn from_vec(from:Vec<T>)->Self{let n=from.len();let mut res=Self{heap:from};let half=n>>1;for i in(0..half).rev(){let(l,r)=(i<<1,(i<<1)|1);if r<n&&res.heap[l]>res.heap[r]{res.heap.swap(l,r);}let k=res.down_heap(r);res.up_heap(k,r);let k=res.down_heap(l);res.up_heap(k,l);}res}pub fn push(&mut self,val:T){self.heap.push(val);if self.len()<2{return;}self.up_heap(self.len()-1,1);}pub fn pop_max(&mut self)->Option<T>{if self.len()<3{self.heap.pop()}else{let res=self.heap.swap_remove(1);let k=self.down_heap(1);self.up_heap(k,1);Some(res)}}pub fn pop_min(&mut self)->Option<T>{if self.len()<2{self.heap.pop()}else{let res=self.heap.swap_remove(0);let k=self.down_heap(0);self.up_heap(k,1);Some(res)}}pub fn max(&self)->Option<&T>{self.heap.get(1).or(self.heap.first())}pub fn min(&self)->Option<&T>{self.heap.first()}}}mod link_cut_tree{use crate::__cargo_equip::crates::ds::{DefaultZST,MapMonoid};use std::fmt::Debug;use std::ops::{Deref,DerefMut};use std::ptr::NonNull;enum Edge<M:MapMonoid>{Light(NodeRef<M>),Heavy(NodeRef<M>),None,}#[derive(Debug,PartialEq)]struct Node<M:MapMonoid>{parent:Option<NodeRef<M>>,left:Option<NodeRef<M>>,right:Option<NodeRef<M>>,index:u32,val:M::M,sum:M::M,lazy:M::Act,}impl<M:MapMonoid>Node<M>{pub fn new(index:usize)->Self{Self{parent:None,left:None,right:None,index:index as u32,val:M::e(),sum:M::e(),lazy:M::id(),}}pub const fn index(&self)->usize{(self.index&!(1<<31))as usize}pub const fn is_reversed(&self)->bool{self.index>=(1<<31)}pub fn toggle(&mut self){self.index^=1<<31;M::reverse(&mut self.sum);(self.left,self.right)=(self.right,self.left);}fn propagate(&mut self){if let Some(mut left)=self.left{left.lazy=M::composite(&left.lazy,&self.lazy);left.sum=M::map(&left.sum,&self.lazy);if self.is_reversed(){left.toggle();}}if let Some(mut right)=self.right{right.lazy=M::composite(&right.lazy,&self.lazy);right.sum=M::map(&right.sum,&self.lazy);if self.is_reversed(){right.toggle();}}self.lazy=M::id();self.index=self.index()as u32;}fn update(&mut self){self.sum=match(self.left,self.right){(Some(l),Some(r))=>M::op(&M::op(&l.sum,&self.val),&r.sum),(Some(l),_)=>M::op(&l.sum,&self.val),(_,Some(r))=>M::op(&self.val,&r.sum),_=>M::map(&self.val,&M::id()),}}}struct NodeRef<M:MapMonoid>(NonNull<Node<M>>);impl<M:MapMonoid>NodeRef<M>{fn new(node:Node<M>)->Self{let reference=Box::leak(Box::new(node));Self(NonNull::new(reference as*mut _).unwrap())}fn connect_left(mut self,mut child:Self){assert_ne!(self.index,child.index);self.left=Some(child);child.parent=Some(self);}fn connect_right(mut self,mut child:Self){assert_ne!(self.index,child.index);self.right=Some(child);child.parent=Some(self);}fn weak_connect_parent(mut self,parent:Self){self.parent=Some(parent);}fn force_connect_parent(mut self,mut parent:Self){parent.right=Some(self);self.parent=Some(parent);}fn disconnect_left(mut self)->Option<Self>{self.left.take().map(|mut left|{left.parent=None;left})}fn disconnect_right(mut self)->Option<Self>{self.right.take().map(|mut right|{right.parent=None;right})}fn disconnect_parent(&mut self)->Edge<M>{if let Some(mut parent)=self.parent{match(parent.left,parent.right){(Some(l),_)if l==*self=>{parent.left=None;self.parent=None;}(_,Some(r))if r==*self=>{parent.right=None;self.parent=None;}_=>{self.parent=None;return Edge::Light(parent);}}Edge::Heavy(parent)}else{Edge::None}}fn rotate_left(mut self)->Self{let Some(mut right)=self.disconnect_right()else{return self;};if let Some(right_left)=right.disconnect_left(){self.connect_right(right_left);}self.update();let self_is_shallow=self.is_left_child();let par=self.disconnect_parent();right.connect_left(self);right.update();match par{Edge::Heavy(mut par)=>{if self_is_shallow{par.connect_left(right);}else{par.connect_right(right);}par.update();}Edge::Light(par)=>{right.weak_connect_parent(par);}Edge::None=>{}}right}fn rotate_right(mut self)->Self{let Some(mut left)=self.disconnect_left()else{return self;};if let Some(left_right)=left.disconnect_right(){self.connect_left(left_right);}self.update();let self_is_shallow=self.is_left_child();let par=self.disconnect_parent();left.connect_right(self);left.update();match par{Edge::Heavy(mut par)=>{if self_is_shallow{par.connect_left(left);}else{par.connect_right(left);}par.update();}Edge::Light(par)=>{left.weak_connect_parent(par);}Edge::None=>{}}left}fn splay(mut self){self.propagate();while!self.is_root(){let&(mut parent)=self.parent.as_ref().unwrap();if parent.is_root(){parent.propagate();self.propagate();if self.is_left_child(){parent.rotate_right();}else{parent.rotate_left();}return;}let&(mut grand_parent)=parent.parent.as_ref().unwrap();grand_parent.propagate();parent.propagate();self.propagate();if self.is_left_child()^parent.is_left_child(){if self.is_left_child(){parent.rotate_right();grand_parent.rotate_left();}else if self.is_right_child(){parent.rotate_left();grand_parent.rotate_right();}else{unreachable!()}}else{if self.is_left_child(){grand_parent.rotate_right();parent.rotate_right();}else if self.is_right_child(){grand_parent.rotate_left();parent.rotate_left();}else{unreachable!()}}}}fn is_left_child(self)->bool{self.parent.map_or(false,|p|p.left.map_or(false,|l|l.index==self.index))}fn is_right_child(self)->bool{self.parent.map_or(false,|p|p.right.map_or(false,|r|r.index==self.index))}fn is_root(self)->bool{self.parent.map_or(true,|p|{p.left.map_or(true,|s|s!=self)&&p.right.map_or(true,|d|d!=self)})}}impl<M:MapMonoid>Clone for NodeRef<M>{fn clone(&self)->Self{*self}}impl<M:MapMonoid>Copy for NodeRef<M>{}impl<M:MapMonoid>PartialEq for NodeRef<M>{fn eq(&self,other:&Self)->bool{self.index==other.index}}impl<M:MapMonoid>Deref for NodeRef<M>{type Target=Node<M>;fn deref(&self)->&Self::Target{unsafe{self.0.as_ref()}}}impl<M:MapMonoid>DerefMut for NodeRef<M>{fn deref_mut(&mut self)->&mut Self::Target{unsafe{self.0.as_mut()}}}impl<M>Debug for NodeRef<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("NodeRef").field("index",&self.index()).field("val",&self.val).field("sum",&self.sum).field("lazy",&self.lazy).field("rev",&self.is_reversed()).field("parent",&self.parent.map(|p|p.index())).field("left",&self.left).field("right",&self.right).finish()}}pub struct LinkCutTree<M:MapMonoid=DefaultZST>{nodes:Vec<NodeRef<M>>,}impl<M:MapMonoid>LinkCutTree<M>{pub fn new(size:usize)->Self{Self{nodes:(0..size).map(|i|NodeRef::new(Node::new(i))).collect(),}}pub fn from_edges(n:usize,edges:impl IntoIterator<Item=(usize,usize)>,)->Result<Self,&'static str>{let mut res=Self::new(n);for(u,v)in edges{res.link_flat(u,v)?;}Ok(res)}pub fn expose(&self,index:usize)->usize{let mut now=self.nodes[index];now.splay();now.right=None;now.update();debug_assert!(now.is_root());while let Some(mut parent)=now.parent{parent.splay();debug_assert!(parent.is_root());now.force_connect_parent(parent);parent.update();now=parent;}self.nodes[index].splay();debug_assert!(self.nodes[index].parent.is_none());now.index()}pub fn root(&self,index:usize)->usize{self.expose(index);let mut now=self.nodes[index];while let Some(left)=now.left{now=left;}now.splay();now.index()}pub fn is_connected(&self,u:usize,v:usize)->bool{if u==v{return true;}self.expose(u);self.expose(v);self.nodes[u].parent.is_some()}pub fn link(&mut self,parent:usize,child:usize)->Result<(),&'static str>{if self.is_connected(parent,child){return Err("These nodes already belong to the same group.");}self.expose(parent);self.expose(child);self.nodes[child].force_connect_parent(self.nodes[parent]);self.nodes[parent].update();Ok(())}pub fn link_flat(&mut self,u:usize,v:usize)->Result<(),&'static str>{self.evert(v);self.link(u,v)?;Ok(())}pub fn cut(&mut self,new_root:usize){self.expose(new_root);self.nodes[new_root].disconnect_left();self.nodes[new_root].update();}pub fn try_cut(&mut self,u:usize,v:usize)->Result<(),&'static str>{self.evert(u);self.expose(v);if self.nodes[u].parent!=Some(self.nodes[v]){return Err("There is no direct connection between node `u` and node `v`.");}self.nodes[v].disconnect_left();self.nodes[v].update();Ok(())}pub fn evert(&mut self,new_root:usize){self.expose(new_root);assert!(self.nodes[new_root].right.is_none());self.nodes[new_root].toggle();self.nodes[new_root].propagate();}pub fn lca(&self,u:usize,v:usize)->Option<usize>{self.is_connected(u,v).then(||{self.expose(u);self.expose(v)})}pub fn set(&mut self,index:usize,val:M::M){self.expose(index);self.nodes[index].val=val;self.nodes[index].update();}pub fn val(&self,index:usize)->Option<&M::M>{self.nodes.get(index).as_ref().map(|n|&n.val)}pub fn update_by(&mut self,index:usize,f:impl Fn(&M::M)->M::M){let new=f(&self.nodes[index].val);self.set(index,new);}pub fn fold(&mut self,u:usize,v:usize)->Option<&M::M>{self.is_connected(u,v).then(||{self.evert(u);assert!(self.nodes[u].is_root());self.expose(v);&self.nodes[v].sum})}pub fn parent(&self,node:usize)->Option<usize>{self.expose(node);let mut par=self.nodes[node].left?;while let Some(r)=par.right{par=r;}Some(par.index())}}impl<M:MapMonoid>Drop for LinkCutTree<M>{fn drop(&mut self){self.nodes.iter_mut().for_each(|p|unsafe{p.parent=None;p.left=None;p.right=None;let _=Box::from_raw(p.0.as_ptr());});self.nodes.clear();}}impl<M>Debug for LinkCutTree<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("LinkCutTree").field("nodes",&self.nodes).finish()}}}mod online_dynamic_connectivity{use crate::__cargo_equip::crates::ds::splay_tree::NodeAllocator;use crate::__cargo_equip::crates::ds::{DefaultZST,EttData,EttLinkError,EulerTourTree,MapMonoid};use std::cell::RefCell;use std::collections::BTreeSet;use std::fmt::Debug;use std::rc::Rc;enum LayeredForest<M:MapMonoid>{Top(EulerTourTree<M>),Other(EulerTourTree<DefaultZST>),}macro_rules!impl_layerd_forests_method{($self:tt,{$($sig:tt)*},{$($met:tt)*})=>{fn$($sig)*{match$self{Self::Top(e)=>e.$($met)*,Self::Other(e)=>e.$($met)*,}}};}impl<M:MapMonoid>LayeredForest<M>{impl_layerd_forests_method!(self,{are_connected(&self,u:usize,v:usize)->bool},{are_connected(u,v)});impl_layerd_forests_method!(self,{link(&mut self,u:usize,v:usize,own_layer:bool)->Result<(),EttLinkError>},{link_as_specified_layer(u,v,own_layer)});impl_layerd_forests_method!(self,{has_edge(&self,u:usize,v:usize)->bool},{has_edge(u,v)});impl_layerd_forests_method!(self,{set_aux_edge(&mut self,u:usize)},{set_aux_edge(u)});impl_layerd_forests_method!(self,{remove_aux_edge(&mut self,u:usize)},{remove_aux_edge(u)});impl_layerd_forests_method!(self,{tree_size(&self,u:usize)->usize},{tree_size(u)});impl_layerd_forests_method!(self,{find_and_unset_own_layers_edge(&self,u:usize)->Option<(usize,usize)>},{find_and_unset_own_layers_edge(u)});impl_layerd_forests_method!(self,{find_vertex_has_aux_edge(&self,u:usize)->Option<usize>},{find_vertex_has_aux_edge(u)});impl_layerd_forests_method!(self,{cut(&mut self,u:usize,v:usize)},{cut(u,v)});fn as_top(&self)->Option<&EulerTourTree<M>>{match self{LayeredForest::Top(ett)=>Some(ett),_=>None,}}fn as_top_mut(&mut self)->Option<&mut EulerTourTree<M>>{match self{LayeredForest::Top(ett)=>Some(ett),_=>None,}}}impl<M>Debug for LayeredForest<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{match self{Self::Top(ett)=>write!(f,"{ett:?}"),Self::Other(ett)=>write!(f,"{ett:?}"),}}}pub struct OnlineDynamicConnectivity<M:MapMonoid>{size:usize,etts:Vec<LayeredForest<M>>,aux_edges:Vec<Vec<BTreeSet<usize>>>,oalloc:Rc<RefCell<NodeAllocator<EttData<DefaultZST>>>>,}impl<M:MapMonoid>OnlineDynamicConnectivity<M>{pub fn new(size:usize)->Self{let alloc=Rc::new(RefCell::new(NodeAllocator::with_capacity((size-1)*2)));Self{size,etts:vec![LayeredForest::Top(EulerTourTree::new_in(size,Rc::clone(&alloc),))],aux_edges:vec![vec![BTreeSet::new();size]],oalloc:Rc::new(RefCell::new(NodeAllocator::with_capacity(8))),}}pub fn from_edges(size:usize,edges:impl IntoIterator<Item=(usize,usize)>)->Self{Self::from_edges_with_values(size,edges,[])}pub fn from_edges_with_values(size:usize,edges:impl IntoIterator<Item=(usize,usize)>,values:impl IntoIterator<Item=(usize,M::M)>,)->Self{let alloc=Rc::new(RefCell::new(NodeAllocator::with_capacity((size-1)*2)));let mut res=Self{size,etts:vec![LayeredForest::Top(EulerTourTree::from_edges_with_values_in(size,[],values,alloc).unwrap(),)],aux_edges:vec![vec![BTreeSet::new();size]],oalloc:Rc::new(RefCell::new(NodeAllocator::with_capacity(8))),};for(u,v)in edges{res.link(u,v).ok();}res}pub fn are_connected(&self,u:usize,v:usize)->bool{self.etts[0].are_connected(u,v)}pub fn link(&mut self,u:usize,v:usize)->Result<(),EttLinkError>{match self.etts[0].link(u,v,true){Err(EttLinkError::MakeCycle)=>{self.add_aux_edge(u,v,0)?;}Err(e)=>return Err(e),_=>{}}Ok(())}fn expand_layer(&mut self){self.etts.push(LayeredForest::Other(EulerTourTree::new_in(self.size,Rc::clone(&self.oalloc),)));self.aux_edges.push(vec![BTreeSet::new();self.size]);}pub fn has_edge(&self,u:usize,v:usize)->bool{self.etts[0].has_edge(u,v)||self.aux_edges.iter().any(|e|e[u].contains(&v))}fn add_aux_edge(&mut self,u:usize,v:usize,layer:usize)->Result<(),EttLinkError>{if!self.aux_edges[layer][u].insert(v){return Err(EttLinkError::EdgeAlreadyExists);}self.aux_edges[layer][v].insert(u);self.etts[layer].set_aux_edge(u);self.etts[layer].set_aux_edge(v);Ok(())}fn remove_aux_edge(&mut self,u:usize,v:usize,layer:usize){if self.aux_edges[layer][u].is_empty(){self.etts[layer].remove_aux_edge(u);}if self.aux_edges[layer][v].is_empty(){self.etts[layer].remove_aux_edge(v);}}pub fn cut(&mut self,mut u:usize,mut v:usize){if u==v{return;}for i in 0..self.etts.len(){if self.aux_edges[i][u].remove(&v){self.aux_edges[i][v].remove(&u);self.remove_aux_edge(u,v,i);return;}}let layers=self.etts.len()+1;for l in 0..layers{if l==layers-1{self.expand_layer();}if!self.etts[l].has_edge(u,v){for i in(0..l).rev(){if self.etts[i].tree_size(u)>self.etts[i].tree_size(v){(u,v)=(v,u)}while let Some((a,b))=self.etts[i].find_and_unset_own_layers_edge(u){self.etts[i+1].link(a,b,true).unwrap();}let mut res=None;'b:while let Some(a)=self.etts[i].find_vertex_has_aux_edge(u){while let Some(b)=self.aux_edges[i][a].pop_first(){self.aux_edges[i][b].remove(&a);self.remove_aux_edge(a,b,i);if self.etts[i].are_connected(b,v){res=Some((a,b));break 'b;}self.add_aux_edge(a,b,i+1).unwrap();}}if let Some((a,b))=res{self.etts[..i].iter_mut().for_each(|e|{e.link(a,b,false).expect("Internal Error, an edge is both tree edge and aux edge")});self.etts[i].link(a,b,true).expect("Internal Error, an edge is both tree edge and aux edge");return;}}return;}self.etts[l].cut(u,v);}}pub fn component_size(&self,u:usize)->usize{self.etts[0].tree_size(u)}pub fn size(&self)->usize{self.size}pub fn vertexes(&self,u:usize)->impl Iterator<Item=usize>+'_{self.etts[0].as_top().unwrap().vertexes(u)}pub fn edges(&self,u:usize)->impl Iterator<Item=(usize,usize)>+'_{self.etts[0].as_top().unwrap().edges(u).chain(self.aux_edges.iter().flat_map(|e|e.iter().enumerate()).flat_map(|(i,s)|s.iter().map(move|&s|(i,s))).filter(|(s,d)|s<d),)}pub fn fold(&self,u:usize)->M::M{let LayeredForest::Top(ett)=&self.etts[0]else{unreachable!()};ett.fold(u)}pub fn set(&mut self,index:usize,value:M::M){self.etts[0].as_top_mut().unwrap().set(index,value);}pub fn update_by(&mut self,index:usize,f:impl Fn(&M::M)->M::M){self.etts[0].as_top_mut().unwrap().update_by(index,f);}}impl<M>Debug for OnlineDynamicConnectivity<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("OnlineDynamicConnectivity").field("etts",&self.etts).field("aux_edges",&format!("{:?}",self.aux_edges).as_str()).finish()}}}mod splay_tree{use std::fmt::Debug;use std::ops::{Deref,DerefMut};use std::ptr::NonNull;pub(in crate::__cargo_equip::crates::ds)trait NodeData:PartialEq+Sized{fn update(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>);fn propagate(&mut self,left:Option<NodeRef<Self>>,right:Option<NodeRef<Self>>);fn aggrmove(&mut self,source:NodeRef<Self>);fn toggle(&mut self){}fn index(&self)->usize;}pub(in crate::__cargo_equip::crates::ds)struct Node<D:NodeData>{parent:Option<NodeRef<D>>,child:[Option<NodeRef<D>>;2],pub(in crate::__cargo_equip::crates::ds)data:D,}impl<D:NodeData>Node<D>{pub(in crate::__cargo_equip::crates::ds)fn new(data:D)->Self{Self{parent:None,child:[None;2],data}}pub(in crate::__cargo_equip::crates::ds)fn initialize(&mut self,data:D){self.parent=None;self.child=[None;2];self.data=data;}pub(in crate::__cargo_equip::crates::ds)fn propagate(&mut self){self.data.propagate(self.left(),self.right());}pub(in crate::__cargo_equip::crates::ds)fn update(&mut self){self.data.update(self.left(),self.right());}pub(in crate::__cargo_equip::crates::ds)fn toggle(&mut self){self.data.toggle();self.child.swap(0,1);}pub(in crate::__cargo_equip::crates::ds)const fn left(&self)->Option<NodeRef<D>>{self.child[0]}pub(in crate::__cargo_equip::crates::ds)const fn right(&self)->Option<NodeRef<D>>{self.child[1]}}impl<D:NodeData>PartialEq for Node<D>{fn eq(&self,other:&Self)->bool{self.data==other.data}}impl<D:NodeData+Debug>Debug for Node<D>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("Node").field("data",&self.data).field("parent",&self.parent.map(|p|p.data.index())).field("left",&self.left()).field("right",&self.right()).finish()}}pub(in crate::__cargo_equip::crates::ds)struct NodeRef<D:NodeData>(pub(in crate::__cargo_equip::crates::ds)NonNull<Node<D>>);impl<D:NodeData>NodeRef<D>{pub(in crate::__cargo_equip::crates::ds)unsafe fn from_raw_unchecked(ptr:*mut Node<D>)->Self{NodeRef(NonNull::new_unchecked(ptr))}fn connect(mut self,mut child:Self,right:bool){self.child[right as usize]=Some(child);child.parent=Some(self);}pub(in crate::__cargo_equip::crates::ds)fn connect_left(self,child:Self){self.connect(child,false);}pub(in crate::__cargo_equip::crates::ds)fn connect_right(self,child:Self){self.connect(child,true);}fn disconnect(mut self,right:bool)->Option<Self>{let mut child=self.child[right as usize].take()?;child.parent=None;Some(child)}pub(in crate::__cargo_equip::crates::ds)fn disconnect_left(self)->Option<Self>{self.disconnect(false)}pub(in crate::__cargo_equip::crates::ds)fn disconnect_right(self)->Option<Self>{self.disconnect(true)}fn disconnect_parent(mut self)->Option<(Self,bool)>{let mut parent=self.parent.take()?;let is_right_child=parent.child[0]!=Some(self);parent.child[is_right_child as usize]=None;Some((parent,is_right_child))}fn rotate(mut self,right:bool)->Self{let left=!right;let Some(mut child)=self.disconnect(left)else{return self;};if let Some(grand_child)=child.disconnect(right){self.connect(grand_child,left);}child.data.aggrmove(self);self.update();if let Some((par,is_right_child))=self.disconnect_parent(){par.connect(child,is_right_child);}child.connect(self,right);child}pub(in crate::__cargo_equip::crates::ds)fn splay(mut self){self.propagate();while let Some(parent)=self.parent{let Some(grand_parent)=parent.parent else{parent.rotate(parent.left()==Some(self));return;};let sf=parent.left()==Some(self);let pf=grand_parent.left()==Some(parent);if sf^pf{parent.rotate(sf);grand_parent.rotate(!sf);}else{grand_parent.rotate(sf);parent.rotate(sf);}}}pub(in crate::__cargo_equip::crates::ds)fn is_root(self)->bool{self.parent.is_none()}pub(in crate::__cargo_equip::crates::ds)fn propagate_all(mut self){if let Some(parent)=self.parent{parent.propagate_all();}self.propagate();}}impl<D:NodeData>Clone for NodeRef<D>{fn clone(&self)->Self{*self}}impl<D:NodeData>Copy for NodeRef<D>{}impl<D:NodeData>PartialEq for NodeRef<D>{fn eq(&self,other:&Self)->bool{self.0==other.0}}impl<D:NodeData>Eq for NodeRef<D>{}impl<D:NodeData>PartialOrd for NodeRef<D>{fn partial_cmp(&self,other:&Self)->Option<std::cmp::Ordering>{Some(self.cmp(other))}}impl<D:NodeData>Ord for NodeRef<D>{fn cmp(&self,other:&Self)->std::cmp::Ordering{self.0.cmp(&other.0)}}impl<D:NodeData>Deref for NodeRef<D>{type Target=Node<D>;fn deref(&self)->&Self::Target{unsafe{self.0.as_ref()}}}impl<D:NodeData>DerefMut for NodeRef<D>{fn deref_mut(&mut self)->&mut Self::Target{unsafe{self.0.as_mut()}}}impl<D:NodeData+Debug>Debug for NodeRef<D>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("NodeRef").field("data",&self.data).field("parent",&self.parent.map(|p|p.data.index())).field("left",&self.left()).field("right",&self.right()).finish()}}pub(in crate::__cargo_equip::crates::ds)struct NodeAllocator<D:NodeData+Default>{cnt:usize,cap:usize,nodes:Vec<Box<[Node<D>]>>,ptr:Vec<NodeRef<D>>,}impl<D:NodeData+Default>NodeAllocator<D>{pub(in crate::__cargo_equip::crates::ds)fn with_capacity(cap:usize)->Self{let cap=cap.max(1);let nodes=vec![(0..cap).map(|_|Node::new(D::default())).collect()];Self{cnt:0,cap,nodes,ptr:vec![]}}pub(in crate::__cargo_equip::crates::ds)fn from_buffer(buf:Box<[Node<D>]>)->Self{if buf.is_empty(){return Self::default();}let nodes=vec![buf];Self{cnt:0,cap:nodes[0].len(),nodes,ptr:vec![]}}pub(in crate::__cargo_equip::crates::ds)fn alloc_uninitialized(&mut self)->NodeRef<D>{self.ptr.pop().unwrap_or_else(||{if self.cnt<self.nodes.last().unwrap().len(){self.cnt+=1;let res=unsafe{NodeRef::from_raw_unchecked(self.nodes.last_mut().unwrap().as_mut_ptr().add(self.cnt-1),)};return res;}self.cnt=0;self.nodes.push((0..self.cap).map(|_|Node::new(D::default())).collect());self.cap<<=1;self.alloc_uninitialized()})}pub(in crate::__cargo_equip::crates::ds)fn alloc(&mut self,data:D)->NodeRef<D>{let mut res=self.alloc_uninitialized();res.initialize(data);res}pub(in crate::__cargo_equip::crates::ds)fn dealloc(&mut self,p:NodeRef<D>){self.ptr.push(p);}}impl<D:NodeData+Default>Default for NodeAllocator<D>{fn default()->Self{NodeAllocator::with_capacity(0)}}}mod wavelet_matrix{use std::collections::{BinaryHeap,HashMap};use std::marker::PhantomData;use std::ops::{Add,Bound,Range,RangeBounds,Sub};use crate::__cargo_equip::crates::ds::{convert_range,DefaultZST};const LARGE_WIDTH:usize=1024;const SMALL_WIDTH:usize=16;type BitBlock=u16;const __BLOCK_WIDTH_CONSTRAINT:()={assert!(1<<LARGE_WIDTH.trailing_zeros()==LARGE_WIDTH);assert!(1<<SMALL_WIDTH.trailing_zeros()==SMALL_WIDTH);assert!(SMALL_WIDTH==BitBlock::BITS as usize);};#[derive(Debug,Clone,PartialEq)]struct BitVector{large:Box<[u32]>,small:Box<[u16]>,data:Box<[BitBlock]>,}impl BitVector{fn new(data:Box<[BitBlock]>)->Self{const L:usize=LARGE_WIDTH/BitBlock::BITS as usize;let(mut large,mut small)=(Vec::with_capacity((data.len()+L-1)/L+1),Vec::with_capacity(data.len()+1),);large.push(0);small.push(0);for large_block in data.chunks(L){for small_block in large_block{small.push(small.last().unwrap()+small_block.count_ones()as u16);}large.push(large.last().unwrap_or(&0)+*small.last().unwrap()as u32);if large_block.len()==L{*small.last_mut().unwrap()=0;}}Self{large:large.into_boxed_slice(),small:small.into_boxed_slice(),data,}}#[target_feature(enable="popcnt")]unsafe fn count<const B:u8>(&self,to:usize)->usize{assert!(B<2);if to==0{return 0;}let l=to/LARGE_WIDTH;let s=to/SMALL_WIDTH;let mut res=self.large[l]as usize+self.small[s]as usize;let rem=to&(SMALL_WIDTH-1);if rem>0{res+=self.data[s].wrapping_shl(BitBlock::BITS-rem as u32).count_ones()as usize;}if B==0{res=to-res;}res}fn access(&self,at:usize)->u16{(self.data[at/BitBlock::BITS as usize]>>(at%BitBlock::BITS as usize))&1}fn position_of<const B:u8>(&self,nth:usize)->usize{assert!(B<2);let(mut l,mut r)=(0,self.data.len()*BitBlock::BITS as usize);while r-l>1{let m=(r+l)/2;if unsafe{self.count::<B>(m)}<=nth{l=m;}else{r=m;}}l}}#[derive(Debug,Clone)]pub struct WaveletMatrix<T,W=DefaultZST,C=DefaultZST>{len:usize,bitvec:Vec<BitVector>,bound:Vec<usize>,first:HashMap<T,u32>,cumsum:Vec<C>,_phantom:PhantomData<W>,}macro_rules!impl_wavelet_matrix{($($t:ty),*)=>{$(impl<W,C>WaveletMatrix<$t,W,C>{#[doc=" Return the length of an original sequence."]pub const fn len(&self)->usize{self.len}#[doc=" Check `self.len() == 0`"]pub const fn is_empty(&self)->bool{self.len()==0}#[doc=" Get the `at`-th element of an original sequence.  "]#[doc=" If `at >= self.len()` is satisfied, return `None`."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 2, 3, 4]);"]#[doc=" assert_eq!(wm.get(0), Some(0));"]#[doc=" assert_eq!(wm.get(3), Some(3));"]#[doc=" // index out of range"]#[doc=" assert!(wm.get(5).is_none());"]#[doc=" ```"]#[doc(alias="access")]pub fn get(&self,at:usize)->Option<$t>{(at<self.len()).then(||{let mut res=0;let mut now=at;for(bitvec,bound)in self.bitvec.iter().zip(self.bound.iter()){let bit=bitvec.access(now)as$t;res=(res<<1)|bit;if bit==0{now=unsafe{bitvec.count::<0>(now)};}else{now=bound+unsafe{bitvec.count::<1>(now)};}}res})}fn countk_to(&self,k:$t,first:usize,to:usize)->usize{let mut b=self.bitvec.len();let mut now=to;for(bitvec,bound)in self.bitvec.iter().zip(self.bound.iter()){b-=1;if(k>>b)&1==0{now=unsafe{bitvec.count::<0>(now)};}else{now=bound+unsafe{bitvec.count::<1>(now)};}}now-first}#[doc=" Count the number of `k` that exists within `range`."]#[doc=""]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.countk(0, 0..6), 2);"]#[doc=" assert_eq!(wm.countk(0, 0..2), 1);"]#[doc=" assert_eq!(wm.countk(1, 2..6), 2);"]#[doc=" assert_eq!(wm.countk(5, 0..6), 0);"]#[doc=" ```"]#[doc(alias="rank")]pub fn countk(&self,k:$t,range:impl RangeBounds<usize>)->usize{let Some(&first)=self.first.get(&k)else{return 0;};let Range{start,end}=convert_range(self.len(),range);assert!(end<=self.len());let mut res=self.countk_to(k,first as usize,end);if start>0{res-=self.countk_to(k,first as usize,start);}res}fn count_less_than(&self,upper:$t,range:impl RangeBounds<usize>)->usize{let Range{mut start,mut end}=convert_range(self.len(),range);assert!(start<=end&&end<=self.len());if<$t>::MAX>>(<$t>::BITS as usize-self.bitvec.len())<upper{return end-start;}if<$t>::MIN==upper{return 0;}let mut b=self.bitvec.len();let mut res=0;for(bitvec,bound)in self.bitvec.iter().zip(self.bound.iter()){b-=1;let(s,e)=unsafe{(bitvec.count::<0>(start),bitvec.count::<0>(end))};if(upper>>b)&1==0{(start,end)=(s,e);}else{res+=e-s;(start,end)=(bound+start-s,bound+end-e);}}res}#[doc=" Count the number of numbers contained `within` the range of the `range` of the number sequence."]#[doc=" "]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=" "]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=" "]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.count_within(.., ..), 6);"]#[doc=" assert_eq!(wm.count_within(0..2, ..), 5);"]#[doc=" assert_eq!(wm.count_within(1.., ..), 4);"]#[doc=" assert_eq!(wm.count_within(1..=1, ..), wm.countk(1, ..));"]#[doc=" ```"]pub fn count_within(&self,within:impl RangeBounds<$t>,range:impl RangeBounds<usize>)->usize{let range=convert_range(self.len(),range);if range.is_empty(){return 0;}let s=match within.start_bound(){Bound::Included(l)=>self.count_less_than(*l,range.clone()),Bound::Excluded(l)if*l==<$t>::MAX=>return 0,Bound::Excluded(l)=>self.count_less_than(l+1,range.clone()),Bound::Unbounded=>0,};(match within.end_bound(){Bound::Included(r)if*r==<$t>::MAX=>range.len(),Bound::Included(r)=>self.count_less_than(r+1,range),Bound::Excluded(r)=>self.count_less_than(*r,range),Bound::Unbounded=>range.len(),})-s}#[doc=" Get `nth`-th `k` in an original sequence.  "]#[doc=" If such an element is not found, return `None`."]#[doc=""]#[doc=" `nth` is 0-index."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.position_of(0, 0), Some(0));"]#[doc=" assert_eq!(wm.position_of(0, 1), Some(2));"]#[doc=" assert_eq!(wm.position_of(0, 2), None);"]#[doc=" assert_eq!(wm.position_of(1, 2), Some(5));"]#[doc=" assert_eq!(wm.position_of(5, 0), None);"]#[doc=" ```"]#[doc(alias="select")]pub fn position_of(&self,mut k:$t,nth:usize)->Option<usize>{let start=*self.first.get(&k)?as usize;(nth<self.countk(k,..self.len())).then(||{let mut now=start+nth;for(bitvec,bound)in self.bitvec.iter().zip(self.bound.iter()).rev(){let bit=k&1;k>>=1;if bit==0{now=bitvec.position_of::<0>(now);}else{now=bitvec.position_of::<1>(now-bound);}}now})}#[doc=" Get `nth`-th smallest element that exists within `range`.  "]#[doc=" If `nth` is longer than the length of `range` or `range` is empty, return `None`."]#[doc=""]#[doc=" `nth` is 0-index."]#[doc=""]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.nth_smallest(0, 0..6), Some(0));"]#[doc=" assert_eq!(wm.nth_smallest(0, 3..6), Some(1));"]#[doc=" assert_eq!(wm.nth_smallest(7, 0..6), None);"]#[doc=" ```"]#[doc(alias="quantile")]pub fn nth_smallest(&self,mut nth:usize,range:impl RangeBounds<usize>)->Option<$t>{let Range{mut start,mut end}=convert_range(self.len(),range);assert!(end<=self.len());(start<end&&nth<end-start).then(||{let mut res=0;for(bitvec,bound)in self.bitvec.iter().zip(self.bound.iter()){let zeros_until_end=unsafe{bitvec.count::<0>(end)};let zeros_until_start=unsafe{bitvec.count::<0>(start)};let zeros=zeros_until_end-zeros_until_start;res<<=1;if nth<zeros{(start,end)=(zeros_until_start,zeros_until_end);}else{res|=1;nth-=zeros;(start,end)=(bound+start-zeros_until_start,bound+end-zeros_until_end,);}}res})}#[doc=" Get `nth`-th smallest element that exists within `range`.  "]#[doc=" If `nth` is longer than the length of `range` or `range` is empty, return `None`."]#[doc=""]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.nth_largest(0, 0..6), Some(2));"]#[doc=" assert_eq!(wm.nth_largest(0, 3..6), Some(2));"]#[doc=" assert_eq!(wm.nth_largest(7, 0..6), None);"]#[doc=" ```"]pub fn nth_largest(&self,nth:usize,range:impl RangeBounds<usize>)->Option<$t>{let range=convert_range(self.len(),range);(!range.is_empty()&&nth<range.len()).then(||self.nth_smallest(range.len()-1-nth,range).unwrap())}#[doc=" Return elements and frequencies within the range indicated by `range` in descending order of frequency.  "]#[doc=" Returned tuples represents `(element, frequency)`."]#[doc=""]#[doc=" This method should in some cases result in very poor performance and should be used with care."]#[doc=""]#[doc=" If there are elements with the same frequency, the order of occurrence is *not defined*."]#[doc=""]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" let mut iter = wm.top_of_mode(..);"]#[doc=" assert_eq!(iter.next(), Some((1, 3)));"]#[doc=" assert_eq!(iter.next(), Some((0, 2)));"]#[doc=" assert_eq!(iter.next(), Some((2, 1)));"]#[doc=" assert_eq!(iter.next(), None);"]#[doc=" ```"]#[doc(alias="topk")]pub fn top_of_mode(&self,range:impl RangeBounds<usize>,)->impl Iterator<Item=($t,usize)>+'_{let Range{start,end}=convert_range(self.len(),range);assert!(end<=self.len());let mut nt=BinaryHeap::new();nt.push((end-start,start,0,0));std::iter::from_fn(move||{while let Some((width,start,value,level))=nt.pop(){if level==self.bitvec.len(){return Some((value,width));}let end=width+start;let bitvec=&self.bitvec[level];let zeros_until_end=unsafe{bitvec.count::<0>(end)};let zeros_until_start=unsafe{bitvec.count::<0>(start)};let zeros=zeros_until_end-zeros_until_start;if zeros>0{nt.push((zeros,zeros_until_start,value<<1,level+1));}if width-zeros>0{nt.push((width-zeros,self.bound[level]+start-zeros_until_start,(value<<1)|1,level+1,));}}None})}#[doc=" Return the sum of elements that exists within `range`."]#[doc=""]#[doc=" Note that performance is worse when most of the elements in the range are distinct."]#[doc=""]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::WaveletMatrix;"]#[doc=""]#[doc=" let wm = WaveletMatrix::from([0u64, 1, 0, 2, 1, 1]);"]#[doc=" assert_eq!(wm.sum(..), 5);"]#[doc=" assert_eq!(wm.sum(2..), 4);"]#[doc=" assert_eq!(wm.sum(..4), 3);"]#[doc=" ```"]pub fn sum(&self,range:impl RangeBounds<usize>)->$t{self.top_of_mode(range).map(|(v,cnt)|v*cnt as$t).sum()}}impl<W,C:StaticRangeSum<W>>WaveletMatrix<$t,W,C>where W:Clone+Copy+Default+Add<W,Output=W>+Sub<W,Output=W>{fn sum_of_weight_less_than(&self,upper:$t,range:Range<usize>)->W{let Range{mut start,mut end}=range;assert!(end<=self.len());if<$t>::MAX>>(<$t>::BITS as usize-self.bitvec.len())<upper{return self.cumsum[0].range_sum(start..end);}if<$t>::MIN==upper{return W::default();}let mut b=self.bitvec.len();let mut res=W::default();for(bitvec,(bound,weights))in self.bitvec.iter().zip(self.bound.iter().zip(self.cumsum.iter().skip(1))){b-=1;let(s,e)=unsafe{(bitvec.count::<0>(start),bitvec.count::<0>(end))};if(upper>>b)&1==0{(start,end)=(s,e);}else{res=res+weights.range_sum(s..e);(start,end)=(bound+start-s,bound+end-e);}}res}#[doc=" Returns the sum of the weights of the points"]#[doc=" whose values are in the `within` range of the `range` of the original sequence."]#[doc=" "]#[doc=" In other words, this method returns the sum of the weights of the points inside the square"]#[doc=" in the value range `within` and definition range `range`,  "]#[doc=" with the index of the number sequence as horizontal axis and the value as vertical axis."]#[doc=" "]#[doc=" # Panics"]#[doc=" - `range` must specify the range within an original sequence."]#[doc=" "]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" // This is the alias of `WaveletMatrix<T, W, CumSum<W>>`."]#[doc=" // `CumSum` can process static range sum queries."]#[doc=" use ds::StaticRectangleSum;"]#[doc=" "]#[doc=" let wm = StaticRectangleSum::from([(0u64, 1u64), (1, 2), (0, 3), (2, 4), (1, 5), (1, 6)]);"]#[doc=" assert_eq!(wm.sum_of_weight(.., ..), 21);"]#[doc=" assert_eq!(wm.sum_of_weight(1.., ..), 17);"]#[doc=" assert_eq!(wm.sum_of_weight(1.., ..3), 2);"]#[doc=" assert_eq!(wm.sum_of_weight(..1, ..), 4);"]#[doc=" ```"]pub fn sum_of_weight(&self,within:impl RangeBounds<$t>,range:impl RangeBounds<usize>)->W{let range=convert_range(self.len(),range);if range.is_empty(){return W::default();}let s=match within.start_bound(){Bound::Included(l)=>self.sum_of_weight_less_than(*l,range.clone()),Bound::Excluded(l)if*l==<$t>::MAX=>return W::default(),Bound::Excluded(l)=>self.sum_of_weight_less_than(l+1,range.clone()),Bound::Unbounded=>W::default(),};(match within.end_bound(){Bound::Included(r)if*r==<$t>::MAX=>self.cumsum[0].range_sum(range),Bound::Included(r)=>self.sum_of_weight_less_than(r+1,range),Bound::Excluded(r)=>self.sum_of_weight_less_than(*r,range),Bound::Unbounded=>self.cumsum[0].range_sum(range),})-s}}impl From<Vec<$t>>for WaveletMatrix<$t>{fn from(value:Vec<$t>)->Self{value.into_iter().map(|v|(v,DefaultZST)).collect::<Self>()}}impl From<&[$t]>for WaveletMatrix<$t>{fn from(value:&[$t])->Self{Self::from(value.to_vec())}}impl<const N:usize>From<[$t;N]>for WaveletMatrix<$t>{fn from(value:[$t;N])->Self{Self::from(&value[..])}}impl FromIterator<$t>for WaveletMatrix<$t>{fn from_iter<T:IntoIterator<Item=$t>>(iter:T)->Self{Self::from(iter.into_iter().collect::<Vec<$t>>())}}impl<W:Clone,C:StaticRangeSum<W>>From<(Vec<$t>,Vec<W>)>for WaveletMatrix<$t,W,C>{fn from(value:(Vec<$t>,Vec<W>))->Self{let(mut value,mut weights)=value;let Some(&max)=value.iter().max()else{return Self::default();};if max==0{let len=(value.len()+BitBlock::BITS as usize-1)/BitBlock::BITS as usize;return Self{len:value.len(),bitvec:vec![BitVector::new(vec![0;len].into_boxed_slice())],bound:vec![value.len()],first:HashMap::from([(0,0)]),cumsum:vec![C::new(&weights[..]);2],_phantom:PhantomData,};}let width=<$t>::BITS-max.leading_zeros();let mut bitvec=vec![];let mut cumsum=vec![C::new(&weights[..])];let mut bound=vec![];let mut working=vec![0;value.len()];let mut working_weights=weights.clone();for r in(0..width).rev(){let bv=BitVector::new(value.chunks(BitBlock::BITS as usize).map(|v|v.iter().rev().fold(0u16,|s,v|(s<<1)|((v>>r)as u16&1))).collect(),);bound.push(unsafe{bv.count::<0>(value.len())});let(mut zeros,mut ones)=(0,*bound.last().unwrap());for(v,w)in value.iter().zip(weights.iter()){if(v>>r)&1==0{working[zeros]=*v;working_weights[zeros]=w.clone();zeros+=1;}else{working[ones]=*v;working_weights[ones]=w.clone();ones+=1;}}(value,working)=(working,value);(weights,working_weights)=(working_weights,weights);cumsum.push(C::new(&weights[..]));bitvec.push(bv);}let mut first=HashMap::from([(value[0],0)]);first.extend(value.windows(2).enumerate().filter_map(|(i,v)|(v[0]!=v[1]).then_some((v[1],i as u32+1))),);Self{len:value.len(),bitvec,bound,first,cumsum,_phantom:PhantomData,}}}impl<W:Clone,C:StaticRangeSum<W>>From<Vec<($t,W)>>for WaveletMatrix<$t,W,C>{fn from(value:Vec<($t,W)>)->Self{let(elements,weights)=value.into_iter().unzip::<$t,W,Vec<$t>,Vec<W>>();Self::from((elements,weights))}}impl<W:Clone,C:StaticRangeSum<W>>From<&[($t,W)]>for WaveletMatrix<$t,W,C>{fn from(value:&[($t,W)])->Self{Self::from(value.into_iter().cloned().unzip::<$t,W,Vec<$t>,Vec<W>>())}}impl<W:Clone,C:StaticRangeSum<W>>From<(&[$t],&[W])>for WaveletMatrix<$t,W,C>{fn from(value:(&[$t],&[W]))->Self{Self::from((value.0.to_vec(),value.1.to_vec()))}}impl<W:Clone,C:StaticRangeSum<W>,const N:usize>From<[($t,W);N]>for WaveletMatrix<$t,W,C>{fn from(value:[($t,W);N])->Self{Self::from(value.into_iter().unzip::<$t,W,Vec<$t>,Vec<W>>())}}impl<W:Clone,C:StaticRangeSum<W>,const N:usize>From<([$t;N],[W;N])>for WaveletMatrix<$t,W,C>{fn from(value:([$t;N],[W;N]))->Self{Self::from((Vec::from(value.0),Vec::from(value.1)))}}impl<W:Clone,C:StaticRangeSum<W>>FromIterator<($t,W)>for WaveletMatrix<$t,W,C>{fn from_iter<T:IntoIterator<Item=($t,W)>>(iter:T)->Self{Self::from(iter.into_iter().unzip::<$t,W,Vec<$t>,Vec<W>>())}}impl<W:Clone,C>Default for WaveletMatrix<$t,W,C>{fn default()->Self{return Self{len:0,bitvec:vec![],bound:vec![],first:HashMap::new(),cumsum:vec![],_phantom:PhantomData,};}})*};}impl_wavelet_matrix!(u8,u16,u32,u64,u128,usize);#[derive(Debug,Clone,Default)]pub struct CumSum<W>where W:Clone+Copy+Add+Sub{cum:Vec<W>,}pub trait StaticRangeSum<W>:Clone+Default{fn new(slice:&[W])->Self;fn range_sum(&self,range:Range<usize>)->W;}impl<W>StaticRangeSum<W>for CumSum<W>where W:Clone+Copy+Default+Add<W,Output=W>+Sub<W,Output=W>{fn new(slice:&[W])->Self{let mut cum=vec![W::default()];cum.extend(slice);for i in 1..cum.len(){cum[i]=cum[i]+cum[i-1];}Self{cum}}fn range_sum(&self,range:Range<usize>)->W{assert!(range.end<=self.cum.len());self.cum[range.end]-self.cum[range.start]}}impl StaticRangeSum<DefaultZST>for DefaultZST{fn new(_:&[DefaultZST])->Self{DefaultZST}fn range_sum(&self,_:Range<usize>)->DefaultZST{DefaultZST}}pub type StaticRectangleSum<T,W> =WaveletMatrix<T,W,CumSum<W>>;}use std::ops::{Bound,Range,RangeBounds};pub use btree_multiset::*;pub use cartesian_tree::*;pub use dynamic_sequence::*;pub use euler_tour_tree::*;pub use fixed_ring_queue::*;pub use interval_heap::*;pub use link_cut_tree::*;pub use online_dynamic_connectivity::*;pub use wavelet_matrix::*;pub trait MapMonoid{type M;type Act;fn e()->Self::M;fn op(l:&Self::M,r:&Self::M)->Self::M;fn id()->Self::Act;fn composite(l:&Self::Act,r:&Self::Act)->Self::Act;fn map(m:&Self::M,act:&Self::Act)->Self::M;fn reverse(m:&mut Self::M){let _=m;}}fn convert_range(len:usize,range:impl RangeBounds<usize>)->Range<usize>{let start=match range.start_bound(){Bound::Included(l)=>*l,Bound::Unbounded=>0,_=>unreachable!(),};let end=match range.end_bound(){Bound::Included(r)=>r+1,Bound::Excluded(r)=>*r,Bound::Unbounded=>len,};Range{start,end}}#[derive(Debug,Clone,Copy,Default,PartialEq,Eq)]pub struct DefaultZST;impl MapMonoid for DefaultZST{type M=();type Act=();fn e()->Self::M{}fn op(_:&Self::M,_:&Self::M)->Self::M{}fn map(_:&Self::M,_:&Self::Act)->Self::M{}fn id()->Self::Act{}fn composite(_:&Self::Act,_:&Self::Act)->Self::Act{}}}
    }

    pub(crate) mod macros {
        pub mod cpio {pub use crate::{__cargo_equip_macro_def_cpio_put as put,__cargo_equip_macro_def_cpio_putln as putln,__cargo_equip_macro_def_cpio_read_value as read_value,__cargo_equip_macro_def_cpio_scan as scan};}
        pub mod ds {}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod cpio {}
        pub mod ds {}
    }
}
